// Generated by CoffeeScript 1.9.2
var Connector, EventEmitter, GenericUtil, MAX_ACQUIRE_TIME, STATES, _, log4js, logger, semLib,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

log4js = global.log4js || (global.log4js = require('log4js'));

logger = log4js.getLogger('Connector');

EventEmitter = require('events').EventEmitter;

GenericUtil = require('./GenericUtil');

semLib = require('sem-lib');

_ = require('lodash');

STATES = {
  INVALID: -1,
  AVAILABLE: 0,
  START_TRANSACTION: 1,
  ROLLBACK: 2,
  COMMIT: 3,
  ACQUIRE: 4,
  RELEASE: 5,
  QUERY: 6,
  FORCE_RELEASE: 6
};

MAX_ACQUIRE_TIME = 1 * 60 * 1000;

module.exports = Connector = (function(superClass) {
  extend(Connector, superClass);

  Connector.prototype.STATES = STATES;

  function Connector(pool, options) {
    var error;
    Connector.__super__.constructor.apply(this, arguments);
    if (!_.isObject(pool)) {
      error = new Error('pool is not defined');
      error.code = 'POOL_UNDEFINED';
      throw error;
    }
    if (_.isPlainObject(options)) {
      this.options = _.clone(options);
    } else {
      this.options = {};
    }
    this.timeout = this.options.timeout || MAX_ACQUIRE_TIME;
    this.resourceSem = semLib.semCreate(1, true);
    this.pool = pool;
    this._savepoints = 0;
    this.state = STATES.AVAILABLE;
    this.acquireTimeout = 0;
    this.resource = 1;
    this.waiting = [];
  }

  Connector.prototype.clone = function() {
    return new Connector(this.pool, this.options);
  };

  Connector.prototype.getDialect = function() {
    return this.pool.getDialect();
  };

  Connector.prototype.getPool = function() {
    return this.pool;
  };

  Connector.prototype.getMaxConnection = function() {
    return this.pool.getMaxConnection();
  };

  Connector.prototype._addSavePoint = function(connection) {
    if (connection) {
      this._connection = connection;
    }
    return this._savepoints++;
  };

  Connector.prototype._removeSavepoint = function() {
    return this._savepoints--;
  };

  Connector.prototype.getState = function() {
    return this.state;
  };

  Connector.prototype.getSavepointsSize = function() {
    return this._savepoints;
  };

  Connector.prototype._stateError = function(expected) {
    var err;
    if (this.state === expected) {
      return;
    }
    err = new Error("Connector must be '" + expected + "' but it is '" + this.state + "'");
    err.code = 'STATE';
    return err;
  };

  Connector.prototype._hasError = function() {
    var error;
    if (this.state === STATES.INVALID) {
      error = new Error('Connector is in invalid state.');
      error.code = 'INVALID_STATE';
      return error;
    }
  };

  Connector.prototype._takeResource = function(state, callback, prior) {
    var err;
    if (err = this._hasError()) {
      return callback(err);
    }
    if (this.resource === 1) {
      this.resource = 0;
      if (state != null) {
        this.state = state;
      }
      callback();
    } else if (prior) {
      this.waiting.unshift([state, callback, prior]);
    } else {
      this.waiting.push([state, callback, prior]);
    }
  };

  Connector.prototype._giveResource = function() {
    var callback, prior, ref, state;
    this.resource = 1;
    if (this.state !== STATES.INVALID) {
      this.state = STATES.AVAILABLE;
    }
    if (this.waiting.length) {
      this.resource = 0;
      ref = this.waiting.shift(), state = ref[0], callback = ref[1], prior = ref[2];
      this._takeResource(state, callback, prior);
    }
  };

  Connector.prototype.acquire = function(callback) {
    var ret;
    logger.trace(this.pool.options.name, 'acquire');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.ACQUIRE, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        _this._acquire(ret);
      };
    })(this));
  };

  Connector.prototype._acquire = function(callback) {
    if (this._savepoints > 0) {
      logger.trace(this.pool.options.name, 'already acquired');
      callback(null, false);
      return;
    }
    this.pool.acquire((function(_this) {
      return function(err, connection) {
        if (err) {
          return callback(err);
        }
        logger.trace(_this.pool.options.name, 'acquired');
        _this._addSavePoint(connection);
        _this.acquireTimeout = setTimeout(function() {
          _this._takeResource(STATES.FORCE_RELEASE, function() {
            if (_this._savepoints === 0) {
              return _this._giveResource();
            }
            _this.state = STATES.INVALID;
            logger.error('Force rollback and release cause acquire last longer than acceptable');
            _this._rollback(function() {
              return _this._giveResource();
            }, true);
          }, true);
        }, _this.timeout);
        return callback(null, true);
      };
    })(this));
  };

  Connector.prototype.query = function(query, callback, options) {
    var ret;
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    this._takeResource(STATES.QUERY, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.trace(_this.pool.options.name, 'automatic acquire for query');
          return _this._acquire(function(err) {
            if (err) {
              return ret(err);
            }
            return _this._query(query, function(err) {
              var args;
              args = Array.prototype.slice.call(arguments, 0);
              logger.trace(_this.pool.options.name, 'automatic release for query');
              return _this._release(function(err) {
                args[0] = err;
                return ret.apply(_this, args);
              }, err);
            }, options);
          });
        }
        _this._query(query, ret, options);
      };
    })(this));
  };

  Connector.prototype._query = function(query, callback, options) {
    if (options == null) {
      options = {};
    }
    logger.trace(this.pool.options.name, '[query] - ' + query);
    return this._connection.query(query, (function(_this) {
      return function(err, res) {
        if (err && options.autoRollback !== false) {
          logger.error(_this.pool.options.name, 'automatic rollback on query error', err);
          return _this._rollback(callback, false, err);
        }
        return callback(err, res);
      };
    })(this));
  };

  Connector.prototype.stream = function(query, callback, done, options) {
    var ret;
    if (options == null) {
      options = {};
    }
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof done === 'function') {
          done.apply(null, arguments);
        }
      };
    })(this);
    this._takeResource(STATES.STREAM, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.trace(_this.pool.options.name, 'automatic acquire for stream');
          return _this._acquire(function(err) {
            if (err) {
              return ret(err);
            }
            logger.trace(_this.pool.options.name, 'automatic release for stream');
            return _this._stream(query, callback, function(err) {
              var args;
              args = Array.prototype.slice.call(arguments, 0);
              return _this._release(function(err) {
                args[0] = err;
                return ret.apply(_this, args);
              }, err);
            }, options);
          });
        }
        _this._stream(query, callback, ret, options);
      };
    })(this));
  };

  Connector.prototype._stream = function(query, callback, done, options) {
    var stream;
    if (options == null) {
      options = {};
    }
    logger.trace(this.pool.options.name, '[stream] - ' + query);
    stream = this._connection.stream(query, function(row) {
      return callback(row, stream);
    }, (function(_this) {
      return function(err) {
        if (err && options.autoRollback !== false) {
          logger.error(_this.pool.options.name, 'automatic rollback on stream error', err);
          return _this._rollback(done, false, err);
        }
        return done.apply(null, arguments);
      };
    })(this));
  };

  Connector.prototype.begin = function(callback, options) {
    var err, ret;
    if (this._savepoints === 0) {
      err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
      err.code = 'NO_CONNECTION';
      return callback(err);
    }
    logger.trace(this.pool.options.name, 'begin');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.START_TRANSACTION, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
          err.code = 'NO_CONNECTION';
          return ret(err);
        }
        return _this._begin(ret, options);
      };
    })(this));
  };

  Connector.prototype._begin = function(callback, options) {
    var err, query;
    if (this._savepoints === 1) {
      query = 'BEGIN';
    } else if (this._savepoints > 0) {
      query = 'SAVEPOINT sp_' + (this._savepoints - 1);
    } else {
      err = new Error('You probably have called this private method outside');
      err.code = 'MESS';
      return callback(err);
    }
    logger.trace(this.pool.options.name, '[query] - ' + query);
    this._connection.query(query, (function(_this) {
      return function(err, res) {
        if (err) {
          return callback(err);
        }
        _this._addSavePoint();
        logger.trace(_this.pool.options.name, 'begun');
        callback(null);
      };
    })(this));
  };

  Connector.prototype.rollback = function(callback, all) {
    var ret;
    if (all == null) {
      all = false;
    }
    logger.trace(this.pool.options.name, 'rollback');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        logger.trace(_this.pool.options.name, 'rollbacked');
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.ROLLBACK, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          return ret(null);
        }
        return _this._rollback(ret, all);
      };
    })(this));
  };

  Connector.prototype._rollback = function(callback, all, errors) {
    var query;
    if (this._savepoints === 1) {
      if (all) {
        return this._release(callback, errors);
      }
      return callback(errors);
    } else if (this._savepoints === 0) {
      return callback(errors);
    } else if (this._savepoints === 2) {
      query = 'ROLLBACK';
    } else {
      query = 'ROLLBACK TO sp_' + (this._savepoints - 2);
    }
    this._removeSavepoint();
    logger.trace(this.pool.options.name, '[query] - ' + query);
    return this._connection.query(query, (function(_this) {
      return function(err) {
        if (err) {
          if (typeof errors === 'undefined') {
            errors = err;
          } else if (errors instanceof Array) {
            errors.push(err);
          } else {
            errors = [errors];
            errors.push(err);
          }
        }
        if (all) {
          return _this._rollback(callback, all, errors);
        }
        return callback(errors);
      };
    })(this));
  };

  Connector.prototype.commit = function(callback, all) {
    var _all, _callback, ret;
    if (all == null) {
      all = false;
    }
    if (typeof callback === 'boolean') {
      _all = callback;
    } else if (typeof all === 'boolean') {
      _all = all;
    }
    if (typeof callback === 'function') {
      _callback = callback;
    } else if (typeof all === 'function') {
      _callback = all;
    }
    callback = _callback;
    all = _all;
    logger.trace(this.pool.options.name, 'commit');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        logger.trace(_this.pool.options.name, 'comitted');
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.COMMIT, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          return ret(null);
        }
        return _this._commit(ret, all);
      };
    })(this));
  };

  Connector.prototype._commit = function(callback, all, errors) {
    var query;
    if (this._savepoints === 1) {
      if (all) {
        return this._release(callback, errors);
      }
      return callback(errors);
    } else if (this._savepoints === 0) {
      return callback(errors);
    } else if (this._savepoints === 2) {
      query = 'COMMIT';
    } else {
      query = 'RELEASE SAVEPOINT sp_' + (this._savepoints - 2);
    }
    logger.trace(this.pool.options.name, '[query] - ' + query);
    return this._connection.query(query, (function(_this) {
      return function(err) {
        if (err) {
          if (typeof errors === 'undefined') {
            errors = err;
          } else if (errors instanceof Array) {
            errors.push(err);
          } else {
            errors = [errors];
            errors.push(err);
          }
        }
        if (err) {
          return _this._rollback(callback, all, errors);
        }
        _this._removeSavepoint();
        if (all) {
          return _this._commit(callback, all, errors);
        }
        return callback(null);
      };
    })(this));
  };

  Connector.prototype.release = function(callback) {
    var ret;
    logger.trace(this.pool.options.name, 'release');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.RELEASE, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.trace(_this.pool.options.name, 'already released');
          return ret(null);
        }
        if (_this._savepoints !== 1) {
          err = new Error('There is a begining transaction. End it before release');
          err.code = 'NO_RELEASE';
          return ret(err);
        }
        _this._release(ret);
      };
    })(this));
  };

  Connector.prototype._release = function(callback, errors) {
    clearTimeout(this.acquireTimeout);
    this.pool.release(this._connection);
    logger.trace(this.pool.options.name, 'released');
    this._removeSavepoint();
    callback(errors);
  };

  Connector.prototype.escape = function() {
    return this.pool.adapter.escape.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.escapeId = function() {
    return this.pool.adapter.escapeId.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.escapeSearch = function() {
    return this.pool.adapter.escapeSearch.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.escapeBeginWith = function() {
    return this.pool.adapter.escapeBeginWith.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.escapeEndWith = function() {
    return this.pool.adapter.escapeEndWith.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.exprEqual = function() {
    return this.pool.adapter.exprEqual.apply(this.pool.adapter, arguments);
  };

  Connector.prototype.exprNotEqual = function() {
    return this.pool.adapter.exprNotEqual.apply(this.pool.adapter, arguments);
  };

  return Connector;

})(EventEmitter);
