// Generated by CoffeeScript 1.12.4
var Connector, EventEmitter, MAX_ACQUIRE_TIME, STATES, _, log4js, logger, semLib,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

log4js = require('./log4js');

logger = log4js.getLogger(__filename.replace(/^(?:.+[\/\\])?([^.\/\\]+)(?:.[^.]+)?$/, '$1'));

EventEmitter = require('events').EventEmitter;

semLib = require('sem-lib');

_ = require('lodash');

STATES = {
  INVALID: -1,
  AVAILABLE: 0,
  START_TRANSACTION: 1,
  ROLLBACK: 2,
  COMMIT: 3,
  ACQUIRE: 4,
  RELEASE: 5,
  QUERY: 6,
  FORCE_RELEASE: 6
};

MAX_ACQUIRE_TIME = 1 * 60 * 1000;

module.exports = Connector = (function(superClass) {
  extend(Connector, superClass);

  Connector.prototype.STATES = STATES;

  function Connector(pool, options) {
    this._giveResource = bind(this._giveResource, this);
    this._checkSafeEnd = bind(this._checkSafeEnd, this);
    this._forceRelease = bind(this._forceRelease, this);
    var error, i, j, len, len1, method, ref, ref1;
    Connector.__super__.constructor.apply(this, arguments);
    if (!_.isObject(pool)) {
      error = new Error('pool is not defined');
      error.code = 'POOL_UNDEFINED';
      throw error;
    }
    ref = ['escape', 'escapeId', 'escapeSearch', 'escapeBeginWith', 'escapeEndWith'];
    for (i = 0, len = ref.length; i < len; i++) {
      method = ref[i];
      if ('function' === typeof pool.adapter[method]) {
        this[method] = pool.adapter[method].bind(pool.adapter);
      }
    }
    ref1 = ['getDialect', 'exec', 'execute'];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      method = ref1[j];
      if ('function' === typeof pool[method]) {
        this[method] = pool[method].bind(pool);
      }
    }
    if (_.isPlainObject(options)) {
      this.options = _.clone(options);
    } else {
      this.options = {};
    }
    this.timeout = this.options.timeout || MAX_ACQUIRE_TIME;
    this.resourceSem = semLib.semCreate(1, true);
    this.pool = pool;
    this._savepoints = 0;
    this.state = STATES.AVAILABLE;
    this.acquireTimeout = 0;
    this.resource = 1;
    this.waiting = [];
  }

  Connector.prototype.clone = function() {
    return new Connector(this.pool, this.options);
  };

  Connector.prototype.getPool = function() {
    return this.pool;
  };

  Connector.prototype.getMaxConnection = function() {
    return this.pool.getMaxConnection();
  };

  Connector.prototype._addSavePoint = function(client) {
    if (client) {
      this._client = client;
      this.acquireTimeout = setTimeout(this._forceRelease, this.timeout);
      client.on('end', this._checkSafeEnd);
      logger.debug('acquired client', client.id);
    }
    return this._savepoints++;
  };

  Connector.prototype._forceRelease = function() {
    this._takeResource(STATES.FORCE_RELEASE, (function(_this) {
      return function() {
        if (_this._savepoints === 0) {
          return _this._giveResource();
        }
        _this.state = STATES.INVALID;
        logger.warn('Force rollback and release cause acquire last longer than acceptable');
        _this._rollback(_this._giveResource, true);
      };
    })(this), true);
  };

  Connector.prototype._checkSafeEnd = function() {
    if (this._savepoints !== 0) {
      logger.warn('client ends in the middle of a transaction');
      this.state = STATES.INVALID;
      this._release(function() {});
    }
  };

  Connector.prototype._removeSavepoint = function() {
    if (--this._savepoints === 0) {
      this._client.removeListener('end', this._checkSafeEnd);
      logger.debug('released client', this._client.id);
      return this._client = null;
    }
  };

  Connector.prototype.getState = function() {
    return this.state;
  };

  Connector.prototype.getSavepointsSize = function() {
    return this._savepoints;
  };

  Connector.prototype._hasError = function() {
    var error;
    if (this.state === STATES.INVALID) {
      error = new Error('Connector is in invalid state.');
      error.code = 'INVALID_STATE';
      return error;
    }
  };

  Connector.prototype._takeResource = function(state, callback, prior) {
    var err;
    if (err = this._hasError()) {
      return callback(err);
    }
    if (this.resource === 1) {
      this.resource = 0;
      if (state != null) {
        this.state = state;
      }
      callback();
    } else if (prior) {
      this.waiting.unshift([state, callback, prior]);
    } else {
      this.waiting.push([state, callback, prior]);
    }
  };

  Connector.prototype._giveResource = function() {
    var callback, prior, ref, state;
    this.resource = 1;
    if (this.state !== STATES.INVALID) {
      this.state = STATES.AVAILABLE;
    }
    if (this.waiting.length) {
      ref = this.waiting.shift(), state = ref[0], callback = ref[1], prior = ref[2];
      this._takeResource(state, callback, prior);
    }
  };

  Connector.prototype.acquire = function(callback) {
    var ret;
    logger.trace(this.pool.options.name, 'acquire');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.ACQUIRE, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        _this._acquire(ret);
      };
    })(this));
  };

  Connector.prototype._acquire = function(callback) {
    if (this._savepoints > 0) {
      logger.trace(this.pool.options.name, 'already acquired');
      callback(null, false);
      return;
    }
    this.pool.acquire((function(_this) {
      return function(err, client) {
        if (err) {
          return callback(err);
        }
        logger.trace(_this.pool.options.name, 'acquired');
        _this._addSavePoint(client);
        return callback(null, true);
      };
    })(this));
  };

  Connector.prototype.query = function(query, callback, options) {
    var ret;
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    this._takeResource(STATES.QUERY, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.trace(_this.pool.options.name, 'automatic acquire for query');
          return _this._acquire(function(err) {
            if (err) {
              return ret(err);
            }
            return _this._query(query, function(err) {
              var args;
              args = Array.prototype.slice.call(arguments, 0);
              logger.trace(_this.pool.options.name, 'automatic release for query');
              return _this._release(function(err) {
                args[0] = err;
                return ret.apply(_this, args);
              }, err);
            }, options);
          });
        }
        _this._query(query, ret, options);
      };
    })(this));
  };

  Connector.prototype._query = function(query, callback, options) {
    if (options == null) {
      options = {};
    }
    logger.trace(this.pool.options.name, '[query] -', query);
    return this._client.query(query, (function(_this) {
      return function(err, res) {
        if (err && options.autoRollback !== false) {
          logger.warn(_this.pool.options.name, 'automatic rollback on query error', err);
          return _this._rollback(callback, false, err);
        }
        return callback(err, res);
      };
    })(this));
  };

  Connector.prototype.stream = function(query, callback, done, options) {
    var ret;
    if (options == null) {
      options = {};
    }
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof done === 'function') {
          done.apply(null, arguments);
        }
      };
    })(this);
    this._takeResource(STATES.STREAM, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.trace(_this.pool.options.name, 'automatic acquire for stream');
          return _this._acquire(function(err) {
            if (err) {
              return ret(err);
            }
            logger.trace(_this.pool.options.name, 'automatic release for stream');
            return _this._stream(query, callback, function(err) {
              var args;
              args = Array.prototype.slice.call(arguments, 0);
              return _this._release(function(err) {
                args[0] = err;
                return ret.apply(_this, args);
              }, err);
            }, options);
          });
        }
        _this._stream(query, callback, ret, options);
      };
    })(this));
  };

  Connector.prototype._stream = function(query, callback, done, options) {
    var stream;
    if (options == null) {
      options = {};
    }
    logger.trace(this.pool.options.name, '[stream] -', query);
    stream = this._client.stream(query, function(row) {
      return callback(row, stream);
    }, (function(_this) {
      return function(err) {
        if (err && options.autoRollback !== false) {
          logger.warn(_this.pool.options.name, 'automatic rollback on stream error', err);
          return _this._rollback(done, false, err);
        }
        return done.apply(null, arguments);
      };
    })(this));
  };

  Connector.prototype.begin = function(callback) {
    var err, ret;
    if (this._savepoints === 0) {
      err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
      err.code = 'NO_CONNECTION';
      return callback(err);
    }
    logger.debug(this.pool.options.name, 'begin');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        logger.debug(_this.pool.options.name, 'begun');
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.START_TRANSACTION, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
          err.code = 'NO_CONNECTION';
          return ret(err);
        }
        return _this._begin(ret);
      };
    })(this));
  };

  Connector.prototype._begin = function(callback) {
    var query;
    if (this._savepoints === 1) {
      query = 'BEGIN';
    } else if (this._savepoints > 0) {
      query = 'SAVEPOINT sp_' + (this._savepoints - 1);
    }
    logger.trace(this.pool.options.name, '[query] -', query);
    this._client.query(query, (function(_this) {
      return function(err, res) {
        if (err) {
          return callback(err);
        }
        _this._addSavePoint();
        logger.trace(_this.pool.options.name, 'begun');
        callback(null);
      };
    })(this));
  };

  Connector.prototype.rollback = function(callback, all) {
    var ret;
    if (all == null) {
      all = false;
    }
    logger.debug(this.pool.options.name, 'rollback');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        logger.debug(_this.pool.options.name, 'rollbacked');
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.ROLLBACK, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          return ret(null);
        }
        return _this._rollback(ret, all);
      };
    })(this));
  };

  Connector.prototype._rollback = function(callback, all, errors) {
    var query;
    if (this._savepoints === 1) {
      if (all) {
        return this._release(callback, errors);
      }
      return callback(errors);
    } else if (this._savepoints === 0) {
      return callback(errors);
    } else if (this._savepoints === 2) {
      query = 'ROLLBACK';
    } else {
      query = 'ROLLBACK TO sp_' + (this._savepoints - 2);
    }
    this._removeSavepoint();
    logger.trace(this.pool.options.name, '[query] -', query);
    return this._client.query(query, (function(_this) {
      return function(err) {
        if (err) {
          if (typeof errors === 'undefined') {
            errors = err;
          } else if (errors instanceof Array) {
            errors.push(err);
          } else {
            errors = [errors];
            errors.push(err);
          }
        }
        if (all) {
          return _this._rollback(callback, all, errors);
        }
        return callback(errors);
      };
    })(this));
  };

  Connector.prototype.commit = function(callback, all) {
    var _all, _callback, ret;
    if (all == null) {
      all = false;
    }
    if (typeof callback === 'boolean') {
      _all = callback;
    } else if (typeof all === 'boolean') {
      _all = all;
    }
    if (typeof callback === 'function') {
      _callback = callback;
    } else if (typeof all === 'function') {
      _callback = all;
    }
    callback = _callback;
    all = _all;
    logger.debug(this.pool.options.name, 'commit');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        logger.debug(_this.pool.options.name, 'comitted');
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.COMMIT, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          return ret(null);
        }
        return _this._commit(ret, all);
      };
    })(this));
  };

  Connector.prototype._commit = function(callback, all, errors) {
    var query;
    if (this._savepoints === 1) {
      if (all) {
        return this._release(callback, errors);
      }
      return callback(errors);
    } else if (this._savepoints === 0) {
      return callback(errors);
    } else if (this._savepoints === 2) {
      query = 'COMMIT';
    } else {
      query = 'RELEASE SAVEPOINT sp_' + (this._savepoints - 2);
    }
    logger.trace(this.pool.options.name, '[query] -', query);
    return this._client.query(query, (function(_this) {
      return function(err) {
        if (err) {
          if (typeof errors === 'undefined') {
            errors = err;
          } else if (errors instanceof Array) {
            errors.push(err);
          } else {
            errors = [errors];
            errors.push(err);
          }
        }
        if (err) {
          return _this._rollback(callback, all, errors);
        }
        _this._removeSavepoint();
        if (all) {
          return _this._commit(callback, all, errors);
        }
        return callback(null);
      };
    })(this));
  };

  Connector.prototype.release = function(callback) {
    var ret;
    logger.debug(this.pool.options.name, 'release');
    ret = (function(_this) {
      return function() {
        _this._giveResource();
        if (typeof callback === 'function') {
          callback.apply(null, arguments);
        }
      };
    })(this);
    return this._takeResource(STATES.RELEASE, (function(_this) {
      return function(err) {
        if (err) {
          return ret(err);
        }
        if (_this._savepoints === 0) {
          logger.debug(_this.pool.options.name, 'already released');
          return ret(null);
        }
        if (_this._savepoints !== 1) {
          err = new Error('There is a begining transaction. End it before release');
          err.code = 'NO_RELEASE';
          return ret(err);
        }
        _this._release(ret);
      };
    })(this));
  };

  Connector.prototype._release = function(callback, errors) {
    clearTimeout(this.acquireTimeout);
    this.pool.release(this._client);
    logger.debug(this.pool.options.name, 'released');
    this._removeSavepoint();
    callback(errors);
  };

  return Connector;

})(EventEmitter);
