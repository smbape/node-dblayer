// Generated by CoffeeScript 1.9.2
(function() {
  var Connector, EventEmitter, GenericUtil, MAX_ACQUIRE_TIME, STATES, _, log4js, logger, semLib,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  log4js = global.log4js || (global.log4js = require('log4js'));

  logger = log4js.getLogger('Connector');

  EventEmitter = require('events').EventEmitter;

  GenericUtil = require('./GenericUtil');

  semLib = require('sem-lib');

  _ = require('lodash');

  STATES = {
    INVALID: -1,
    AVAILABLE: 0,
    START_TRANSACTION: 1,
    ROLLBACK: 2,
    COMMIT: 3,
    ACQUIRE: 4,
    RELEASE: 5,
    QUERY: 6,
    FORCE_RELEASE: 6
  };

  MAX_ACQUIRE_TIME = 5 * 60 * 1000;

  module.exports = Connector = (function(superClass) {
    extend(Connector, superClass);

    Connector.prototype.STATES = STATES;

    function Connector(pool, options) {
      var error;
      Connector.__super__.constructor.apply(this, arguments);
      if (!_.isObject(pool)) {
        error = new Error('pool is not defined');
        error.code = 'POOL_UNDEFINED';
        throw error;
      }
      if (_.isPlainObject(options)) {
        this.options = _.clone(options);
      } else {
        this.options = {};
      }
      this.timeout = this.options.timeout || MAX_ACQUIRE_TIME;
      this.resourceSem = semLib.semCreate(1, true);
      this.pool = pool;
      this._savepoints = 0;
      this.state = STATES.AVAILABLE;
      this.acquireTimeout = 0;
    }

    Connector.prototype.clone = function() {
      return new Connector(this.pool, this.options);
    };

    Connector.prototype.getDialect = function() {
      return this.pool.getDialect();
    };

    Connector.prototype.escape = function() {
      return this.pool.adapter.escape.apply(this.pool.adapter, arguments);
    };

    Connector.prototype.escapeId = function() {
      return this.pool.adapter.escapeId.apply(this.pool.adapter, arguments);
    };

    Connector.prototype.exprEqual = function() {
      return this.pool.adapter.exprEqual.apply(this.pool.adapter, arguments);
    };

    Connector.prototype.exprNotEqual = function() {
      return this.pool.adapter.exprNotEqual.apply(this.pool.adapter, arguments);
    };

    Connector.prototype.getInnerPool = function() {
      return this.pool.pool;
    };

    Connector.prototype.getMaxConnection = function() {
      return this.pool.getMaxConnection();
    };

    Connector.prototype._addSavePoint = function(connection) {
      if (connection) {
        this._connection = connection;
      }
      return this._savepoints++;
    };

    Connector.prototype._removeSavepoint = function() {
      return this._savepoints--;
    };

    Connector.prototype.getState = function() {
      return this.state;
    };

    Connector.prototype.getSavepointsSize = function() {
      return this._savepoints;
    };

    Connector.prototype._stateError = function(expected) {
      var err;
      if (this.state === expected) {
        return;
      }
      err = new Error("Connector must be '" + expected + "' but it is '" + this.state + "'");
      err.code = 'STATE';
      return err;
    };

    Connector.prototype._hasError = function() {
      var error;
      if (this.state === STATES.INVALID) {
        error = new Error('Connector is in invalid state.');
        error.code = 'INVALID_STATE';
        return error;
      }
    };

    Connector.prototype._takeResource = function(state, settings) {
      var err, onTake;
      if (_.isPlainObject(settings)) {
        onTake = typeof settings.onTake === 'function' ? settings.onTake : (function() {});
        settings = _.clone(settings);
      } else {
        onTake = settings;
        settings = {};
      }
      if (err = this._hasError()) {
        return onTake(err);
      }
      settings.onTake = (function(_this) {
        return function() {
          return onTake(_this._hasError());
        };
      })(this);
      if (state != null) {
        this.state = state;
      }
      return this.resourceSem.semTake(settings);
    };

    Connector.prototype._giveResource = function() {
      if (this.state !== STATES.INVALID) {
        this.state = STATES.AVAILABLE;
      }
      return this.resourceSem.semGive();
    };

    Connector.prototype.acquire = function(callback) {
      var ret;
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      return this._takeResource(STATES.ACQUIRE, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          _this._acquire(ret);
        };
      })(this));
    };

    Connector.prototype._acquire = function(callback) {
      if (this._savepoints > 0) {
        return callback(null, false);
      }
      this.pool.acquire((function(_this) {
        return function(err, connection) {
          if (err) {
            return callback(err);
          }
          _this._addSavePoint(connection);
          _this.acquireTimeout = setTimeout(function() {
            return _this._takeResource(STATES.FORCE_RELEASE, {
              priority: 1,
              onTake: function() {
                if (_this._savepoints === 0) {
                  return _this._giveResource();
                }
                _this.state = STATES.INVALID;
                logger.error('Force rollback and release cause acquire last longer than acceptable');
                return _this._rollback(function() {
                  return _this._giveResource();
                }, true);
              }
            });
          }, _this.timeout);
          logger.trace('acquire connection');
          return callback(null, true);
        };
      })(this));
    };

    Connector.prototype.query = function(query, callback, options) {
      var ret;
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      this._takeResource(STATES.QUERY, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            logger.trace('automatic acquire for query');
            return _this._acquire(function(err) {
              if (err) {
                return ret(err);
              }
              return _this._query(query, function(err) {
                var args;
                args = Array.prototype.slice.call(arguments, 0);
                logger.trace('automatic release for query');
                return _this._release(function(err) {
                  args[0] = err;
                  return ret.apply(_this, args);
                }, err);
              }, options);
            });
          }
          _this._query(query, ret, options);
        };
      })(this));
    };

    Connector.prototype._query = function(query, callback, options) {
      if (options == null) {
        options = {};
      }
      logger.trace('[query] - ' + query);
      return this._connection.query(query, (function(_this) {
        return function(err, res) {
          if (err && options.autoRollback !== false) {
            logger.trace('automatic rollback on query error');
            return _this._rollback(callback, false, err);
          }
          return callback(err, res);
        };
      })(this));
    };

    Connector.prototype.stream = function(query, callback, done, options) {
      var ret;
      if (options == null) {
        options = {};
      }
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof done === 'function') {
            done.apply(null, arguments);
          }
        };
      })(this);
      this._takeResource(STATES.STREAM, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            logger.trace('automatic acquire for stream');
            return _this._acquire(function(err) {
              if (err) {
                return ret(err);
              }
              logger.trace('automatic release for stream');
              return _this._stream(query, callback, function(err) {
                var args;
                args = Array.prototype.slice.call(arguments, 0);
                return _this._release(function(err) {
                  args[0] = err;
                  return ret.apply(_this, args);
                }, err);
              }, options);
            });
          }
          _this._stream(query, callback, ret, options);
        };
      })(this));
    };

    Connector.prototype._stream = function(query, callback, done, options) {
      var stream;
      if (options == null) {
        options = {};
      }
      logger.trace('[stream] - ' + query);
      stream = this._connection.stream(query, function(row) {
        return callback(row, stream);
      }, (function(_this) {
        return function(err) {
          if (err && options.autoRollback !== false) {
            logger.trace('automatic rollback on stream error');
            return _this._rollback(done, false, err);
          }
          return done.apply(null, arguments);
        };
      })(this));
    };

    Connector.prototype.begin = function(callback, options) {
      var err, ret;
      if (this._savepoints === 0) {
        err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
        err.code = 'NO_CONNECTION';
        return callback(err);
      }
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      return this._takeResource(STATES.START_TRANSACTION, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            err = new Error('Connector has no active connection. You must acquire a connection before begining a transaction.');
            err.code = 'NO_CONNECTION';
            return ret(err);
          }
          return _this._begin(ret);
        };
      })(this));
    };

    Connector.prototype._begin = function(callback) {
      var err, query;
      if (this._savepoints === 1) {
        query = 'BEGIN';
      } else if (this._savepoints > 0) {
        query = 'SAVEPOINT sp_' + (this._savepoints - 1);
      } else {
        err = new Error('You probably have called this private method outside');
        err.code = 'MESS';
        return callback(err);
      }
      logger.trace('[query] - ' + query);
      this._connection.query(query, (function(_this) {
        return function(err, res) {
          if (err) {
            return callback(err);
          }
          _this._addSavePoint();
          callback(null);
        };
      })(this));
    };

    Connector.prototype.rollback = function(callback, all) {
      var ret;
      if (all == null) {
        all = false;
      }
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      return this._takeResource(STATES.ROLLBACK, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            return ret(null);
          }
          return _this._rollback(ret, all);
        };
      })(this));
    };

    Connector.prototype._rollback = function(callback, all, errors) {
      var query;
      if (this._savepoints === 1) {
        if (all) {
          return this._release(callback, errors);
        }
        return callback(errors);
      } else if (this._savepoints === 0) {
        return callback(errors);
      } else if (this._savepoints === 2) {
        query = 'ROLLBACK';
      } else {
        query = 'ROLLBACK TO sp_' + (this._savepoints - 2);
      }
      this._removeSavepoint();
      logger.trace('[query] - ' + query);
      return this._connection.query(query, (function(_this) {
        return function(err) {
          if (err) {
            if (typeof errors === 'undefined') {
              errors = err;
            } else if (errors instanceof Array) {
              errors.push(err);
            } else {
              errors = [errors];
              errors.push(err);
            }
          }
          if (all) {
            return _this._rollback(callback, all, errors);
          }
          return callback(errors);
        };
      })(this));
    };

    Connector.prototype.commit = function(callback, all) {
      var _all, _callback, ret;
      if (all == null) {
        all = false;
      }
      if (typeof callback === 'boolean') {
        _all = callback;
      } else if (typeof all === 'boolean') {
        _all = all;
      }
      if (typeof callback === 'function') {
        _callback = callback;
      } else if (typeof all === 'function') {
        _callback = all;
      }
      callback = _callback;
      all = _all;
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      return this._takeResource(STATES.COMMIT, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            return ret(null);
          }
          return _this._commit(ret, all);
        };
      })(this));
    };

    Connector.prototype._commit = function(callback, all, errors) {
      var query;
      if (this._savepoints === 1) {
        if (all) {
          return this._release(callback, errors);
        }
        return callback(errors);
      } else if (this._savepoints === 0) {
        return callback(errors);
      } else if (this._savepoints === 2) {
        query = 'COMMIT';
      } else {
        query = 'RELEASE SAVEPOINT sp_' + (this._savepoints - 2);
      }
      logger.trace('[query] - ' + query);
      return this._connection.query(query, (function(_this) {
        return function(err) {
          if (err) {
            if (typeof errors === 'undefined') {
              errors = err;
            } else if (errors instanceof Array) {
              errors.push(err);
            } else {
              errors = [errors];
              errors.push(err);
            }
          }
          if (err) {
            return _this._rollback(callback, all, errors);
          }
          _this._removeSavepoint();
          if (all) {
            return _this._commit(callback, all, errors);
          }
          return callback(null);
        };
      })(this));
    };

    Connector.prototype.release = function(callback) {
      var ret;
      ret = (function(_this) {
        return function() {
          _this._giveResource();
          if (typeof callback === 'function') {
            callback.apply(null, arguments);
          }
        };
      })(this);
      return this._takeResource(STATES.RELEASE, (function(_this) {
        return function(err) {
          if (err) {
            return ret(err);
          }
          if (_this._savepoints === 0) {
            return ret(null);
          }
          if (_this._savepoints !== 1) {
            err = new Error('There is a begining transaction. End it before release');
            err.code = 'NO_RELEASE';
            return ret(err);
          }
          _this._release(ret);
        };
      })(this));
    };

    Connector.prototype._release = function(callback, errors) {
      clearTimeout(this.acquireTimeout);
      logger.trace('release connection');
      this.pool.release(this._connection);
      this._removeSavepoint();
      callback(errors);
    };

    return Connector;

  })(EventEmitter);

}).call(this);
