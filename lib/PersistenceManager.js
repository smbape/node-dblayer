// Generated by CoffeeScript 1.9.2
var CompiledMapping, DeleteQuery, GenericUtil, InsertQuery, PRIMITIVE_TYPES, PersistenceManager, RowMap, SelectQuery, UpdateQuery, _, _addUpdateOrDeleteCondition, _addWhereCondition, _getCacheId, _getInitializeCondition, assertValidModelInstance, async, isValidModelInstance, log4js, logger, semLib, squel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

log4js = global.log4js || (global.log4js = require('log4js'));

logger = log4js.getLogger('PersistenceManager');

GenericUtil = require('./GenericUtil');

_ = require('lodash');

squel = require('./SquelPatch');

RowMap = require('./RowMap');

CompiledMapping = require('./CompiledMapping');

async = require('async');

semLib = require('sem-lib');

module.exports = PersistenceManager = (function(superClass) {
  extend(PersistenceManager, superClass);

  function PersistenceManager() {
    return PersistenceManager.__super__.constructor.apply(this, arguments);
  }

  return PersistenceManager;

})(CompiledMapping);

isValidModelInstance = function(model) {
  var err, i, len, method, ref;
  if (!model || 'object' !== typeof model) {
    err = new Error('Invalid model');
    err.code = 'INVALID_MODEL';
    return err;
  }
  ref = ['get', 'set', 'unset', 'toJSON'];
  for (i = 0, len = ref.length; i < len; i++) {
    method = ref[i];
    if ('function' !== typeof model[method]) {
      err = new Error("method " + method + " was not found");
      err.code = 'INVALID_MODEL';
      return err;
    }
  }
  return true;
};

assertValidModelInstance = function(model) {
  var err;
  err = isValidModelInstance(model);
  if (err instanceof Error) {
    throw err;
  }
};

PersistenceManager.prototype.dialects = {
  postgres: {
    squelOptions: {
      replaceSingleQuotes: true,
      nameQuoteCharacter: '"',
      fieldAliasQuoteCharacter: '"',
      tableAliasQuoteCharacter: '"'
    },
    decorateInsert: function(query, column) {
      if (GenericUtil.notEmptyString(column)) {
        return query += ' RETURNING "' + column + '"';
      } else {
        return query;
      }
    }
  },
  mysql: {
    squelOptions: {
      replaceSingleQuotes: true,
      nameQuoteCharacter: '`',
      fieldAliasQuoteCharacter: '`',
      tableAliasQuoteCharacter: '`'
    }
  },
  sqlite3: {
    squelOptions: {
      replaceSingleQuotes: true,
      nameQuoteCharacter: '"',
      fieldAliasQuoteCharacter: '"',
      tableAliasQuoteCharacter: '"'
    }
  }
};

PersistenceManager.prototype.getSquelOptions = function(dialect) {
  var instance;
  if (this instanceof PersistenceManager) {
    instance = this;
  } else {
    instance = PersistenceManager.prototype;
  }
  if (instance.dialects.hasOwnProperty(dialect)) {
    return _.clone(instance.dialects[dialect].squelOptions);
  }
};

PersistenceManager.prototype.decorateInsert = function(dialect, query, column) {
  if (this.dialects.hasOwnProperty(dialect) && 'function' === typeof this.dialects[dialect].decorateInsert) {
    return this.dialects[dialect].decorateInsert(query, column);
  } else {
    return query;
  }
};

PersistenceManager.prototype.insert = function(model, options, callback) {
  var connector, err, query;
  connector = options.connector;
  try {
    query = this.getInsertQuery(model, _.extend({
      dialect: connector.getDialect()
    }, options, {
      autoRollback: false
    }));
  } catch (_error) {
    err = _error;
    return callback(err);
  }
  connector.acquire(function(err, performed) {
    if (err) {
      return callback(err);
    }
    connector.begin(function(err) {
      if (err) {
        if (performed) {
          connector.release(function(_err) {
            callback(_err ? [err, _err] : err);
          });
          return;
        }
        callback(err);
        return;
      }
      query.execute(connector, function(err) {
        var args, method;
        if (err) {
          method = 'rollback';
        } else {
          method = 'commit';
        }
        args = Array.prototype.slice.call(arguments, 0);
        connector[method](function(err) {
          if (err) {
            if (args[0]) {
              args[0] = [err, args[0]];
            } else {
              args[0] = err;
            }
          }
          if (performed) {
            connector.release(function(err) {
              callback.apply(null, args);
            });
          } else {
            callback.apply(null, args);
          }
        });
      });
    });
  });
};

PersistenceManager.prototype.getInsertQuery = function(model, options) {
  return new InsertQuery(this, model, options);
};

PersistenceManager.prototype.list = function(className, options, callback) {
  var connector, err, query;
  connector = options.connector;
  try {
    query = this.getSelectQuery(className, _.extend({
      dialect: connector.getDialect()
    }, options));
  } catch (_error) {
    err = _error;
    return callback(err);
  }
  return query.list(connector, callback);
};

PersistenceManager.prototype.stream = function(className, options, callback, done) {
  var connector, err, listConnector, query;
  connector = options.connector;
  listConnector = options.listConnector || connector.clone();
  try {
    query = this.getSelectQuery(className, _.extend({
      dialect: connector.getDialect()
    }, options));
  } catch (_error) {
    err = _error;
    return done(err);
  }
  return query.stream(connector, listConnector, callback, done);
};

PersistenceManager.prototype.getSelectQuery = function(className, options) {
  var definition;
  if (!options.where && _.isPlainObject(options.attributes)) {
    definition = this._getDefinition(className);
    options.where = _getInitializeCondition(this, null, className, definition, _.extend({}, options, {
      useDefinitionColumn: false
    }));
  }
  return new SelectQuery(this, className, options);
};

PersistenceManager.prototype.update = function(model, options, callback) {
  var connector, err, query;
  connector = options.connector;
  try {
    query = this.getUpdateQuery(model, _.extend({
      dialect: connector.getDialect()
    }, options, {
      autoRollback: false
    }));
  } catch (_error) {
    err = _error;
    return callback(err);
  }
  connector.acquire(function(err, performed) {
    if (err) {
      return callback(err);
    }
    connector.begin(function(err) {
      if (err) {
        if (performed) {
          connector.release(function(_err) {
            callback(_err ? [err, _err] : err);
          });
          return;
        }
        callback(err);
        return;
      }
      query.execute(connector, function(err) {
        var args, method;
        if (err) {
          method = 'rollback';
        } else {
          method = 'commit';
        }
        args = Array.prototype.slice.call(arguments, 0);
        connector[method](function(err) {
          if (err) {
            if (args[0]) {
              args[0] = [err, args[0]];
            } else {
              args[0] = err;
            }
          }
          if (performed) {
            connector.release(function(err) {
              callback.apply(null, args);
            });
          } else {
            callback.apply(null, args);
          }
        });
      });
    });
  });
};

PersistenceManager.prototype.getUpdateQuery = function(model, options) {
  return new UpdateQuery(this, model, options);
};

PersistenceManager.prototype["delete"] = PersistenceManager.prototype.remove = function(model, options, callback) {
  var connector, err, query;
  connector = options.connector;
  try {
    query = this.getDeleteQuery(model, _.extend({
      dialect: connector.getDialect()
    }, options, {
      autoRollback: false
    }));
  } catch (_error) {
    err = _error;
    return callback(err);
  }
  query.execute(connector, callback);
};

PersistenceManager.prototype.getDeleteQuery = function(model, options) {
  return new DeleteQuery(this, model, options);
};

PersistenceManager.prototype.save = function(model, options, callback) {
  var backup, className, definition, err, where;
  if ((err = isValidModelInstance(model)) instanceof Error) {
    callback(err);
  }
  if ('function' !== typeof callback) {
    callback = function() {};
  }
  className = options.className || model.className;
  definition = this._getDefinition(className);
  try {
    where = _getInitializeCondition(this, model, className, definition, _.extend({}, options, {
      useDefinitionColumn: false,
      useAttributes: false
    }));
  } catch (_error) {
    err = _error;
    callback(err);
    return;
  }
  if (where.length === 0) {
    this.insert(model, _.extend({}, options, {
      reflect: true
    }), callback);
  } else {
    backup = options;
    options = _.extend({}, options, {
      where: where,
      limit: 2
    });
    this.list(className, options, (function(_this) {
      return function(err, models) {
        if (err) {
          return callback(err);
        }
        if (models.length === 1) {
          _this.update(model, backup, callback);
        } else {
          _this.insert(model, _.extend({}, backup, {
            reflect: true
          }), callback);
        }
      };
    })(this));
  }
};

PersistenceManager.prototype.initializeOrInsert = function(model, options, callback) {
  var backup, className, definition, err, where;
  if ((err = isValidModelInstance(model)) instanceof Error) {
    callback(err);
  }
  if (arguments.length === 2 && 'function' === typeof options) {
    callback = options;
  }
  if (!_.isPlainObject(options)) {
    options = {};
  }
  if ('function' !== typeof callback) {
    callback = function() {};
  }
  className = options.className || model.className;
  definition = this._getDefinition(className);
  try {
    where = _getInitializeCondition(this, model, className, definition, _.extend({}, options, {
      useDefinitionColumn: false,
      useAttributes: false
    }));
  } catch (_error) {
    err = _error;
    callback(err);
    return;
  }
  if (where.length === 0) {
    this.insert(model, _.extend({}, options, {
      reflect: true
    }), callback);
  } else {
    backup = options;
    options = _.extend({}, options, {
      where: where,
      limit: 2
    });
    this.list(className, options, (function(_this) {
      return function(err, models) {
        if (err) {
          return callback(err);
        }
        if (models.length === 1) {
          model.set(models[0].attributes);
          callback(err, model.get(definition.id.name));
        } else {
          _this.insert(model, _.extend({}, backup, {
            reflect: true
          }), callback);
        }
      };
    })(this));
  }
};

PersistenceManager.prototype.initialize = function(model, options, callback) {
  var className, definition, err;
  if ((err = isValidModelInstance(model)) instanceof Error) {
    callback(err);
  }
  if ('function' !== typeof callback) {
    callback = function() {};
  }
  if (!_.isObject(model)) {
    err = new Error('No model');
    err.code = 'NO_MODEL';
    return callback(err);
  }
  className = options.className || model.className;
  definition = this._getDefinition(className);
  options = _.extend({}, options, {
    models: [model]
  });
  try {
    options.where = _getInitializeCondition(this, model, className, definition, _.extend({}, options, {
      useDefinitionColumn: false
    }));
  } catch (_error) {
    err = _error;
    callback(err);
    return;
  }
  return this.list(className, options, callback);
};

_getInitializeCondition = function(pMgr, model, className, definition, options) {
  var attr, attributes, connector, constraint, i, index, isSetted, j, k, len, len1, len2, prop, ref, value, where;
  connector = options.connector;
  if (typeof options.where === 'undefined') {
    if (!model) {
      attributes = options.attributes;
    } else if (_.isPlainObject(definition.id) && (value = model.get(definition.id.name))) {
      attributes = {};
      attributes[definition.id.name] = value;
    } else {
      if (definition.constraints.unique.length !== 0 && (options.useAttributes === false || !options.attributes)) {
        attributes = {};
        ref = definition.constraints.unique;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          constraint = ref[index];
          isSetted = true;
          for (j = 0, len1 = constraint.length; j < len1; j++) {
            prop = constraint[j];
            value = model.get(prop);
            if (value === null || 'undefined' === typeof value) {
              isSetted = false;
              break;
            }
            attributes[prop] = value;
          }
          if (isSetted) {
            break;
          }
        }
      }
      if (!isSetted && options.useAttributes !== false) {
        attributes = options.attributes || model.toJSON();
      }
    }
    where = [];
    if (_.isPlainObject(attributes)) {
      for (attr in attributes) {
        value = attributes[attr];
        _addWhereCondition(pMgr, model, attr, value, definition, connector, where, options);
      }
    } else if (Array.isArray(attributes)) {
      for (k = 0, len2 = attributes.length; k < len2; k++) {
        attr = attributes[k];
        value = model.get(attr);
        _addWhereCondition(pMgr, model, attr, value, definition, connector, where, options);
      }
    }
  } else {
    where = options.where;
  }
  if (isSetted) {
    _.isPlainObject(options.result) || (options.result = {});
    options.result.constraint = index;
  }
  return where || [];
};

PRIMITIVE_TYPES = /^(?:string|boolean|number)$/;

_addWhereCondition = function(pMgr, model, attr, value, definition, connector, where, options) {
  var column, propClassName, propDef;
  if (typeof value === 'undefined') {
    return;
  }
  if (options.useDefinitionColumn) {
    column = connector.escapeId(definition.properties[attr].column);
  } else {
    column = '{' + attr + '}';
  }
  propDef = definition.availableProperties[attr].definition;
  if (_.isPlainObject(propDef.handlers) && typeof propDef.handlers.write === 'function') {
    value = propDef.handlers.write(value, model, options);
  }
  if (PRIMITIVE_TYPES.test(typeof value)) {
    where.push(column + ' = ' + connector.escape(value));
  } else if (_.isObject(value)) {
    propClassName = propDef.className;
    value = value.get(pMgr.getIdName(propClassName));
    if (typeof value !== 'undefined') {
      if (value === null) {
        where.push(column + ' IS NULL');
      } else if (PRIMITIVE_TYPES.test(typeof value)) {
        where.push(column + ' = ' + connector.escape(value));
      }
    }
  }
};

InsertQuery = (function() {
  function InsertQuery(pMgr, model, options) {
    var className, column, connector, definition, err, fields, handlers, i, id, idName, insert, insertHandler, len, mixin, parentModel, prop, propDef, ref, ref1, value, writeHandler;
    if (options == null) {
      options = {};
    }
    assertValidModelInstance(model);
    this.getModel = function() {
      return model;
    };
    this.getManager = function() {
      return pMgr;
    };
    this.getOptions = function() {
      return options;
    };
    this.getDefinition = function() {
      return definition;
    };
    connector = options.connector;
    if (connector) {
      this.escapeId = function(str) {
        return connector.escapeId(str);
      };
    } else {
      this.escapeId = function(str) {
        return str;
      };
    }
    fields = {};
    this.getFields = function(column) {
      return fields;
    };
    this.set = function(column, value) {
      insert.set(this.escapeId(column), value);
      return fields[column] = value;
    };
    this.toString = this.oriToString = function() {
      return insert.toString();
    };
    className = options.className || model.className;
    definition = pMgr._getDefinition(className);
    insert = squel.insert(pMgr.getSquelOptions(options.dialect)).into(this.escapeId(definition.table));
    if (definition.mixins.length > 0) {
      this.toString = function() {
        return insert.toParam().text;
      };
      this.toParam = function() {
        var i, index, len, mixin, params, ref;
        params = insert.toParam();
        ref = definition.mixins;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          mixin = ref[index];
          params.values[index] = new InsertQuery(pMgr, model, _.extend({}, options, {
            className: mixin.className
          }));
        }
        return params;
      };
      ref = definition.mixins;
      for (i = 0, len = ref.length; i < len; i++) {
        mixin = ref[i];
        insert.set(this.escapeId(mixin.column), '$id');
      }
    }
    idName = pMgr.getIdName(className);
    if (idName !== null) {
      id = model.get(idName);
    }
    if (id) {
      insert.set(this.escapeId(definition.id.column), id);
    }
    ref1 = definition.properties;
    for (prop in ref1) {
      propDef = ref1[prop];
      column = propDef.column;
      if (propDef.hasOwnProperty('className')) {
        parentModel = model.get(prop);
        if (typeof parentModel === 'undefined') {
          continue;
        }
        prop = pMgr._getDefinition(propDef.className);
        if (parentModel === null || typeof parentModel === 'number') {
          value = parentModel;
        } else if (typeof parentModel === 'string') {
          if (parentModel.length === 0) {
            value = null;
          } else {
            value = parentModel;
          }
        } else {
          value = parentModel.get(prop.id.name);
        }
        if (typeof value === 'undefined') {
          err = new Error("[" + className + "] - [" + propDef.className + "]: id is not defined. Save property value before saving model");
          err.code = 'NO_ID';
          throw err;
        }
      } else {
        value = model.get(prop);
      }
      handlers = propDef.handlers;
      insertHandler = null;
      writeHandler = null;
      if (typeof handlers !== 'undefined') {
        insertHandler = handlers.insert;
        writeHandler = handlers.write;
      }
      if (typeof value === 'undefined' && typeof insertHandler === 'function') {
        value = insertHandler(model, options, {
          column: column
        });
      }
      if (typeof value === 'undefined') {
        continue;
      }
      if (typeof writeHandler === 'function') {
        value = writeHandler(value, model, options);
      }
      if (typeof value === 'undefined') {
        continue;
      }
      insert.set(this.escapeId(column), value);
    }
    this.toString();
  }

  InsertQuery.prototype.execute = function(connector, callback) {
    var i, idIndex, index, len, params, ref, tasks, value;
    if (this.toString === this.oriToString) {
      this._execute(connector, callback);
      return;
    }
    params = this.toParam();
    idIndex = 0;
    tasks = [];
    ref = params.values;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      value = ref[index];
      if (value instanceof InsertQuery) {
        tasks.push(((function(_this) {
          return function(query) {
            return function(next) {
              return query.execute(connector, function(err, id) {
                var column, definition;
                if (err) {
                  return next(err);
                }
                definition = _this.getDefinition();
                column = definition.mixins[idIndex++].column;
                _this.set(column, id);
                return next();
              });
            };
          };
        })(this))(value));
      } else {
        break;
      }
    }
    async.series(tasks, (function(_this) {
      return function(err) {
        if (err) {
          return callback(err);
        }
        _this._execute(connector, callback);
      };
    })(this));
  };

  InsertQuery.prototype._execute = function(connector, callback) {
    var definition, fields, model, options, pMgr, query;
    pMgr = this.getManager();
    query = this.oriToString();
    definition = this.getDefinition();
    model = this.getModel();
    fields = this.getFields();
    options = this.getOptions();
    query = pMgr.decorateInsert(options.dialect, query, definition.id.column);
    connector.query(query, function(err, res) {
      var id, where;
      if (err) {
        return callback(err);
      }
      if (definition.id.hasOwnProperty('column')) {
        if (fields[definition.id.column]) {
          id = fields[definition.id.column];
        } else if (res.hasOwnProperty('lastInsertId')) {
          id = res.lastInsertId;
        } else {
          id = Array.isArray(res.rows) && res.rows.length > 0 && res.rows[0][definition.id.column];
        }
      }
      logger.trace('[' + definition.className + '] - INSERT ' + id);
      if (options.reflect) {
        if (definition.id.hasOwnProperty('column')) {
          where = '{' + pMgr.getIdName(definition.className) + '} = ' + id;
        }
        options = _.extend({}, options, {
          where: where
        });
        pMgr.initialize(model, options, function(err, models) {
          return callback(err, id);
        });
      } else {
        callback(err, id);
      }
    }, options.executeOptions);
  };

  return InsertQuery;

})();

_getCacheId = function(options) {
  var arr, i, item, j, json, k, len, len1, len2, opt, ref, ref1, val;
  json = {};
  ref = ['dialect', 'type', 'count', 'attributes', 'fields', 'join', 'where', 'group', 'having', 'order', 'limit', 'offset'];
  for (i = 0, len = ref.length; i < len; i++) {
    opt = ref[i];
    if (options.hasOwnProperty(opt)) {
      if (Array.isArray(options[opt])) {
        json[opt] = [];
        ref1 = options[opt];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          val = ref1[j];
          if (Array.isArray(val)) {
            arr = [];
            json[opt].push(arr);
            for (k = 0, len2 = val.length; k < len2; k++) {
              item = val[k];
              arr.push(JSON.stringify(item));
            }
          } else {
            json[opt].push(JSON.stringify(val));
          }
        }
      } else {
        json[opt] = JSON.stringify(options[opt]);
      }
    }
  }
  return JSON.stringify(json);
};

PersistenceManager.prototype.addCachedRowMap = function(cacheId, className, rowMap) {
  var cache, json;
  logger.trace('add cache', className, cacheId);
  json = _.pick(rowMap, ['_infos', '_tableAliases', '_tabId', '_columnAliases', '_colId', '_tables', '_mixins', '_joining']);
  return cache = this.classes[className].cache[cacheId] = {
    rowMap: JSON.stringify(json),
    template: rowMap.getTemplate(),
    select: JSON.stringify(rowMap.select)
  };
};

PersistenceManager.prototype.getCachedRowMap = function(cacheId, className, options) {
  var cache, rowMap, select;
  cache = this.classes[className].cache[cacheId];
  if (!cache) {
    return;
  }
  logger.trace('read cache', className, cacheId);
  rowMap = new RowMap(className, this, options, true);
  select = new squel.select.constructor();
  _.extend(select, JSON.parse(cache.select));
  _.extend(rowMap, JSON.parse(cache.rowMap));
  rowMap.template = cache.template;
  rowMap.select = select;
  rowMap.values = options.values;
  rowMap._initialize();
  rowMap._processColumns();
  if (options.count) {
    rowMap._selectCount();
  }
  rowMap._updateInfos();
  return rowMap;
};

PersistenceManager.SelectQuery = PersistenceManager.prototype.SelectQuery = SelectQuery = (function() {
  function SelectQuery(pMgr, className, options) {
    var cacheId, rowMap, select, useCache;
    if (arguments.length === 1) {
      if (arguments[0] instanceof RowMap) {
        this.rowMap = arguments[0];
        return this;
      } else {
        throw new Error('Given parameter do not resolve to a RowMap');
      }
    }
    useCache = options.cache !== false;
    if (useCache) {
      cacheId = _getCacheId(options);
    }
    if (!useCache || !(rowMap = pMgr.getCachedRowMap(cacheId, className, options))) {
      select = squel.select(pMgr.getSquelOptions(options.dialect));
      rowMap = new RowMap(className, pMgr, _.extend({}, options, {
        select: select
      }));
      select.toParam();
      select.toString();
      if (useCache) {
        this.cacheId = cacheId;
        pMgr.addCachedRowMap(cacheId, className, rowMap);
      }
    }
    this.rowMap = rowMap;
    return this;
  }

  SelectQuery.prototype.toString = function() {
    return this.rowMap.toString();
  };

  SelectQuery.prototype.stream = function(streamConnector, listConnector, callback, done) {
    var doneSem, hasError, models, options, pMgr, query, ret, rowMap, timeout;
    if ('function' !== typeof callback) {
      callback = function() {};
    }
    if ('function' !== typeof done) {
      done = function() {};
    }
    rowMap = this.rowMap;
    query = rowMap.toString();
    pMgr = rowMap.manager;
    options = rowMap.options;
    models = options.models || [];
    doneSem = semLib.semCreate();
    doneSem.semGive();
    timeout = 60 * 1000;
    hasError = false;
    ret = function(err, fields) {
      doneSem.semTake({
        timeout: timeout,
        onTake: function() {
          if (hasError) {
            if (_.isObject(err)) {
              err.subError = hasError;
            } else {
              err = hasError;
            }
          }
          done(err, fields);
        }
      });
    };
    return streamConnector.stream(query, function(row, stream) {
      var err, model, tasks;
      tasks = [];
      model = rowMap.initModel(row, null, tasks);
      if (tasks.length > 0) {
        if (listConnector === streamConnector || (listConnector.getPool() === streamConnector.getPool() && listConnector.getMaxConnection() < 2)) {
          err = new Error('List connector and stream connector are the same. To retrieve nested data, listConnector must be different from streamConnector and if used pools are the same, they must admit more than 1 connection');
          err.code = 'STREAM_CONNECTION';
          stream.emit('error', err);
          return;
        }
        stream.pause();
        doneSem.semTake({
          priority: 1,
          timeout: timeout
        });
        async.eachSeries(tasks, function(task, next) {
          pMgr.list(task.className, _.extend({
            connector: listConnector,
            dialect: options.dialect
          }, task.options), function(err, models) {
            var msg;
            if (err) {
              return next(err);
            }
            if (models.length !== 1) {
              msg = 'Expecting one result. Given ' + models.length + '.';
              if (models.length === 0) {
                msg += '\n    You are most likely querying uncomitted data. listConnector has it\'s own transaction. Therefore, only committed changes will be seen.';
              }
              msg += '\n    Checks those cases: database error, library bug, something else.';
              err = new Error(msg);
              err.code = 'UNKNOWN';
              return next(err);
            }
            next();
          });
        }, function(err) {
          doneSem.semGive();
          stream.resume();
          if (err) {
            hasError = err;
            stream.emit('error', err);
          } else {
            callback(model, stream);
          }
        });
        return;
      }
      callback(model, stream);
    }, ret, options.executeOptions);
  };

  SelectQuery.prototype.toQueryString = function() {
    return this.toString();
  };

  SelectQuery.prototype.list = function(connector, callback) {
    var options, pMgr, query, rowMap;
    if ('function' !== typeof callback) {
      callback = function() {};
    }
    rowMap = this.rowMap;
    query = rowMap.toString();
    pMgr = rowMap.manager;
    options = rowMap.options;
    connector.query(query, function(err, res) {
      var i, index, len, model, models, ret, row, rows, tasks;
      if (err) {
        return callback(err);
      }
      rows = res.rows;
      if (rows.length === 0) {
        return callback(err, rows);
      }
      ret = [];
      if (Array.isArray(options.models)) {
        models = options.models;
        if (models.length !== rows.length) {
          err = new Error('Returned rows and given number of models doesn\'t match');
          err.extend = [models.length, rows.length];
          err.code = 'OPT_MODELS';
          return callback(err);
        }
      } else {
        models = [];
      }
      tasks = [];
      for (index = i = 0, len = rows.length; i < len; index = ++i) {
        row = rows[index];
        model = rowMap.initModel(row, models[index], tasks);
        ret.push(model);
      }
      if (tasks.length > 0) {
        async.eachSeries(tasks, function(task, next) {
          pMgr.list(task.className, _.extend({
            connector: options.connector,
            dialect: options.dialect
          }, task.options), function(err, models) {
            if (err) {
              return next(err);
            }
            if (models.length !== 1) {
              err = new Error('database is corrupted or there is bug');
              err.code = 'UNKNOWN';
              return next(err);
            }
            next();
          });
        }, function(err) {
          if (err) {
            return callback(err);
          }
          callback(null, ret);
        });
        return;
      }
      if (options.count) {
        callback(null, ret[0].count);
      } else {
        callback(null, ret);
      }
    }, options, options.executeOptions);
    return this;
  };

  return SelectQuery;

})();

_addUpdateOrDeleteCondition = function(action, name, connector, pMgr, model, className, definition, options) {
  var condition, err, hasNoCondition, hasNoId, i, id, idName, len, result, where;
  idName = pMgr.getIdName(className);
  if (typeof idName !== 'string' || idName.length === 0) {
    idName = null;
  }
  if (definition.constraints.unique.length === 0 && idName === null) {
    err = new Error("Cannot " + name + " " + className + " models because id has not been defined");
    err.code = name.toUpperCase();
    throw err;
  }
  if (idName !== null) {
    id = model.get(idName);
  }
  hasNoCondition = hasNoId = id === null || 'undefined' === typeof id;
  if (hasNoId) {
    options = _.extend({}, options, {
      useDefinitionColumn: true
    });
    where = _getInitializeCondition(pMgr, model, className, definition, options);
    result = options.result;
    hasNoCondition = where.length === 0;
    for (i = 0, len = where.length; i < len; i++) {
      condition = where[i];
      action.where(condition);
    }
  } else {
    action.where(connector.escapeId(definition.id.column) + ' = ' + connector.escape(id));
  }
  if (hasNoCondition) {
    err = new Error("Cannot " + name + " " + className + " model because id is null or undefined");
    err.code = name.toUpperCase();
    throw err;
  }
  return result;
};

UpdateQuery = (function() {
  function UpdateQuery(pMgr, model, options) {
    var changeCondition, className, column, connector, constraint, definition, dontLock, dontQuote, handlers, lock, lockCondition, parentModel, prop, propDef, ref, result, update, updateHandler, value, writeHandler;
    if (options == null) {
      options = {};
    }
    assertValidModelInstance(model);
    this.getModel = function() {
      return model;
    };
    this.getManager = function() {
      return pMgr;
    };
    this.getOptions = function() {
      return options;
    };
    this.toString = this.oriToString = function() {
      return update.toString();
    };
    this.getDefinition = function() {
      return definition;
    };
    this.setChangeCondition = function() {
      update.where(changeCondition);
      return this;
    };
    connector = options.connector;
    if (connector) {
      this.escapeId = function(str) {
        return connector.escapeId(str);
      };
    } else {
      this.escapeId = function(str) {
        return str;
      };
    }
    className = options.className || model.className;
    definition = pMgr._getDefinition(className);
    update = squel.update(pMgr.getSquelOptions(options.dialect)).table(this.escapeId(definition.table));
    result = _addUpdateOrDeleteCondition(update, 'update', connector, pMgr, model, className, definition, options);
    changeCondition = squel.expr();
    this.lockCondition = lockCondition = squel.expr();
    ref = definition.properties;
    for (prop in ref) {
      propDef = ref[prop];
      if (result) {
        constraint = definition.constraints.unique[result.constraint];
        if (-1 !== constraint.indexOf(prop)) {
          continue;
        }
      }
      if (propDef.hasOwnProperty('className') && typeof (parentModel = model.get(prop)) !== 'undefined') {
        if (parentModel === null || typeof parentModel === 'number') {
          value = parentModel;
        } else if (typeof parentModel === 'string') {
          if (parentModel.length === 0) {
            value = null;
          } else {
            value = parentModel;
          }
        } else {
          value = parentModel.get(pMgr._getDefinition(propDef.className).id.name);
        }
      } else {
        value = model.get(prop);
      }
      column = propDef.column;
      handlers = propDef.handlers;
      if (_.isObject(options.overrides) && _.isObject(options.overrides[prop])) {
        if (_.isObject(options.overrides[prop].handlers)) {
          handlers = _.extend({}, handlers, options.overrides[prop].handlers);
        }
        dontQuote = options.overrides[prop].dontQuote;
        dontLock = options.overrides[prop].dontLock;
      }
      writeHandler = void 0;
      updateHandler = void 0;
      if (typeof handlers !== 'undefined') {
        if (typeof handlers.write === 'function') {
          writeHandler = handlers.write;
        }
        if (typeof handlers.update === 'function') {
          updateHandler = handlers.update;
        }
      }
      if (!dontLock && propDef.lock) {
        lock = value;
        if (typeof writeHandler === 'function') {
          lock = writeHandler(lock, model, options);
          lockCondition.and(connector.exprEqual(lock, connector.escapeId(column)));
        }
      }
      if (typeof updateHandler === 'function') {
        value = updateHandler(model, options, {
          column: column
        });
      }
      if (typeof value === 'undefined') {
        continue;
      }
      if (typeof writeHandler === 'function') {
        value = writeHandler(value, model, options);
      }
      if (typeof value === 'undefined') {
        continue;
      }
      update.set(this.escapeId(column), value, {
        dontQuote: !!dontQuote
      });
      this.hasData = true;
      if (!dontLock && !propDef.lock) {
        changeCondition.or(connector.exprNotEqual(value, connector.escapeId(column)));
      }
    }
    update.where(lockCondition);
    if (definition.mixins.length === 0) {
      this.setChangeCondition();
    } else {
      if (this.hasData) {
        this.toString = function() {
          return update.toString();
        };
      } else {
        this.toString = function() {
          return '';
        };
      }
      this.toParam = function() {
        var i, index, len, mixin, params, ref1;
        if (this.hasData) {
          params = update.toParam();
        } else {
          params = {
            values: []
          };
        }
        ref1 = definition.mixins;
        for (index = i = 0, len = ref1.length; i < len; index = ++i) {
          mixin = ref1[index];
          params.values.push(new UpdateQuery(pMgr, model, {
            className: mixin.className,
            dialect: options.dialect,
            connector: connector
          }));
        }
        return params;
      };
    }
    if (this.hasData) {
      this.toString();
    }
  }

  UpdateQuery.prototype.execute = function(connector, callback) {
    var definition, hasUpdate, i, idIndex, index, params, ref, tasks, value;
    if (this.toString === this.oriToString) {
      return this._execute(connector, callback);
    }
    params = this.toParam();
    idIndex = 0;
    tasks = [];
    for (index = i = ref = params.values.length - 1; i >= 0; index = i += -1) {
      value = params.values[index];
      if (value instanceof UpdateQuery && value.hasData) {
        (function(query, connector) {
          tasks.push(function(next) {
            query.execute(connector, next);
          });
        })(value, connector);
      } else {
        break;
      }
    }
    hasUpdate = false;
    definition = this.getDefinition();
    async.series(tasks, (function(_this) {
      return function(err, results) {
        var extended, id, j, len, result;
        if (err) {
          return callback(err);
        }
        if (Array.isArray(results) && results.length > 0) {
          for (j = 0, len = results.length; j < len; j++) {
            result = results[j];
            if (Array.isArray(result) && result.length > 0) {
              id = result[0];
              extended = result[1];
              if (!extended) {
                logger.trace('[' + definition.className + '] - UPDATE: has update ' + id);
                hasUpdate = true;
                break;
              }
            }
          }
          if (Array.isArray(results[results.length - 1])) {
            id = results[results.length - 1][0];
          }
        }
        if (!_this.hasData) {
          callback(err, id, !hasUpdate);
          return;
        }
        if (!hasUpdate) {
          logger.trace('[' + definition.className + '] - UPDATE: has no update ' + id);
          _this.setChangeCondition();
        }
        _this._execute(connector, function(err, id, extended) {
          hasUpdate = !extended;
          callback(err, id, extended);
        });
      };
    })(this));
  };

  UpdateQuery.prototype._execute = function(connector, callback) {
    var definition, model, options, pMgr, query;
    pMgr = this.getManager();
    query = this.oriToString();
    definition = this.getDefinition();
    model = this.getModel();
    options = this.getOptions();
    query = pMgr.decorateInsert(options.dialect, query, definition.id.column);
    connector.query(query, function(err, res) {
      var hasNoUpdate, id, where;
      if (err) {
        return callback(err);
      }
      if (res.hasOwnProperty('affectedRows')) {
        hasNoUpdate = res.affectedRows === 0;
      } else if (definition.id.hasOwnProperty('column') && res.rows) {
        hasNoUpdate = res.rows.length === 0;
      } else if (res.hasOwnProperty('rowCount')) {
        hasNoUpdate = res.rowCount === 0;
      }
      id = model.get(definition.id.name);
      if ('undefined' === typeof id) {
        try {
          where = _getInitializeCondition(pMgr, model, definition.className, definition, _.extend({}, options, {
            useDefinitionColumn: false
          }));
        } catch (_error) {
          err = _error;
          callback(err);
          return;
        }
      } else if (definition.id.hasOwnProperty('column')) {
        where = '{' + pMgr.getIdName(definition.className) + '} = ' + id;
      }
      options = _.extend({}, options, {
        where: where
      });
      pMgr.initialize(model, options, function(err, models) {
        var extended;
        if (err) {
          return callback(err);
        }
        id = model.get(definition.id.name);
        if (hasNoUpdate) {
          if (models.length === 0) {
            err = new Error('id or lock condition');
            err.code = 'NO_UPDATE';
            logger.trace('[' + definition.className + '] - NO UPDATE ' + id);
          } else {
            extended = 'no-update';
          }
        } else {
          logger.trace('[' + definition.className + '] - UPDATE ' + id);
        }
        callback(err, id, extended);
      });
    }, options.executeOptions);
  };

  return UpdateQuery;

})();

DeleteQuery = (function() {
  function DeleteQuery(pMgr, model, options) {
    var className, column, connector, definition, handlers, prop, propDef, ref, remove, value, writeHandler;
    if (options == null) {
      options = {};
    }
    assertValidModelInstance(model);
    this.toParam = function() {
      return remove.toParam();
    };
    this.toString = this.oriToString = function() {
      return remove.toString();
    };
    this.getOptions = function() {
      return options;
    };
    connector = options.connector;
    className = options.className || model.className;
    definition = pMgr._getDefinition(className);
    remove = squel["delete"](pMgr.getSquelOptions(options.dialect)).from(connector.escapeId(definition.table));
    _addUpdateOrDeleteCondition(remove, 'delete', connector, pMgr, model, className, definition, options);
    ref = definition.properties;
    for (prop in ref) {
      propDef = ref[prop];
      if (propDef.hasOwnProperty('className')) {
        continue;
      }
      if (propDef.lock) {
        column = propDef.column;
        value = model.get(prop);
        handlers = propDef.handlers;
        writeHandler = null;
        if (typeof handlers !== 'undefined') {
          writeHandler = handlers.write;
        }
        if (typeof writeHandler === 'function') {
          value = writeHandler(value, model, options);
        }
        remove.where(connector.escapeId(column) + ' = ' + connector.escape(value));
      }
    }
    if (definition.mixins.length > 0) {
      this.toString = function() {
        return remove.toString();
      };
      this.toParam = function() {
        var i, index, len, mixin, params, ref1;
        params = remove.toParam();
        ref1 = definition.mixins;
        for (index = i = 0, len = ref1.length; i < len; index = ++i) {
          mixin = ref1[index];
          params.values.push(new DeleteQuery(pMgr, model, {
            className: mixin.className,
            dialect: options.dialect,
            connector: connector
          }));
        }
        return params;
      };
    }
    this.toString();
  }

  DeleteQuery.prototype.execute = function(connector, callback) {
    var i, idIndex, index, next, params, ref, tasks, value;
    next = function(err, res) {
      if (err) {
        return callback(err);
      }
      if (!res.affectedRows && res.hasOwnProperty('rowCount')) {
        res.affectedRows = res.rowCount;
      }
      callback(err, res);
    };
    if (this.toString === this.oriToString) {
      return this._execute(connector, next);
    }
    params = this.toParam();
    idIndex = 0;
    tasks = [];
    for (index = i = ref = params.values.length - 1; i >= 0; index = i += -1) {
      value = params.values[index];
      if (value instanceof DeleteQuery) {
        (function(query) {
          tasks.push(function(next) {
            query.execute(connector, next);
          });
        })(value);
      } else {
        break;
      }
    }
    this._execute(connector, function(err, res) {
      if (err) {
        return next(err);
      }
      async.series(tasks, function(err, results) {
        var j, len, result;
        if (err) {
          return next(err);
        }
        for (j = 0, len = results.length; j < len; j++) {
          result = results[j];
          if (result.affectedRows === 0) {
            return next(new Error('sub class has not been deleted'));
          }
        }
        next(err, res);
      });
    });
  };

  DeleteQuery.prototype._execute = function(connector, callback) {
    var query;
    query = this.oriToString();
    connector.query(query, callback, this.getOptions().executeOptions);
  };

  return DeleteQuery;

})();
