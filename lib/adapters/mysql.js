// Generated by CoffeeScript 1.9.2
var ConnectionConfig, GenericUtil, HWM, MySQLConnection, MySQLLibConnection, _, adapter, common, logger, mysql, once, path, prependListener,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

mysql = require('mysql');

MySQLLibConnection = require('mysql/lib/Connection');

ConnectionConfig = require('mysql/lib/ConnectionConfig');

prependListener = require('prepend-listener');

once = require('once');

_ = require('lodash');

path = require('path');

GenericUtil = require('../GenericUtil');

HWM = Math.pow(2, 7);

logger = log4js.getLogger('MySQLAdapter');

adapter = {
  name: 'mysql',
  createQuery: function(text, values, callback) {
    var emitClose, hasError, query, result, stream;
    if (typeof callback === 'undefined' && typeof values === 'function') {
      callback = values;
      values = void 0;
    }
    values = values || [];
    query = mysql.createQuery(text, values);
    stream = query.stream({
      highWaterMark: HWM
    });
    emitClose = once(stream.emit.bind(stream, 'close'));
    prependListener(query, 'end', emitClose);
    stream.query = query;
    stream.text = text;
    stream.values = values;
    stream.callback = callback;
    if (typeof callback === 'function') {
      result = {
        rows: [],
        rowCount: 0,
        lastInsertId: 0,
        fields: null,
        fieldCount: 0
      };
      hasError = false;
      stream.on('error', function(err) {
        emitClose();
        hasError = true;
        this.callback(err);
      });
      stream.on('fields', function(fields) {
        result.fields = fields;
      });
      stream.on('data', function(row) {
        if (row.constructor.name === 'OkPacket') {
          result.fieldCount = row.fieldCount;
          result.affectedRows = row.affectedRows;
          result.changedRows = row.changedRows;
          result.lastInsertId = row.insertId;
        } else {
          ++result.rowCount;
          result.rows.push(row);
        }
      });
      stream.on('end', function() {
        if (!hasError) {
          this.callback(null, result);
        }
      });
    }
    stream.once('end', function() {
      delete this.query;
    });
    return stream;
  },
  createConnection: function(options, callback) {
    var client;
    if (typeof callback !== 'function') {
      callback = (function() {});
    }
    client = new MySQLConnection(options);
    return client.connect(function(err) {
      if (err) {
        return callback(err);
      }
      return callback(err, client);
    });
  }
};

MySQLConnection = (function(superClass) {
  extend(MySQLConnection, superClass);

  MySQLConnection.prototype.adapter = adapter;

  function MySQLConnection(options) {
    this.options = _.clone(options);
    MySQLConnection.__super__.constructor.call(this, {
      config: new ConnectionConfig(options)
    });
  }

  MySQLConnection.prototype.query = function(query, params, callback) {
    var stream;
    stream = adapter.createQuery(query, params, callback);
    MySQLConnection.__super__.query.call(this, stream.query);
    return stream;
  };

  MySQLConnection.prototype.stream = function(query, params, callback, done) {
    var hasError, result, stream;
    if (arguments.length === 3) {
      done = callback;
      callback = params;
      params = [];
    }
    if (!(params instanceof Array)) {
      params = [];
    }
    if (typeof done !== 'function') {
      done = (function() {});
    }
    stream = MySQLLibConnection.prototype.query.call(this, query, params).stream({
      highWaterMark: HWM
    });
    hasError = false;
    result = {
      rowCount: 0
    };
    stream.once('error', function(err) {
      hasError = err;
      done(err);
    });
    stream.on('fields', function(fields) {
      result.fields = fields;
    });
    stream.on('data', function(row) {
      if (row.constructor.name === 'OkPacket') {
        result.fieldCount = row.fieldCount;
        result.affectedRows = row.affectedRows;
        result.changedRows = row.changedRows;
        result.lastInsertId = row.insertId;
      } else {
        ++result.rowCount;
        callback(row);
      }
    });
    stream.once('end', function() {
      if (!hasError) {
        done(void 0, result);
      }
    });
    return stream;
  };

  return MySQLConnection;

})(MySQLLibConnection);

common = require('./common');

_.extend(adapter, common);

_.extend(adapter, {
  escape: function(value) {
    return MySQLConnection.prototype.escape.call({
      config: {}
    }, value);
  },
  escapeId: MySQLConnection.prototype.escapeId,
  escapeSearch: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.MYSQL].search);
  },
  escapeBeginWith: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.MYSQL].begin);
  },
  escapeEndWith: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.MYSQL].end);
  }
});

module.exports = adapter;
