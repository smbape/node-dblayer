// Generated by CoffeeScript 1.9.0
(function() {
  var ConnectionConfig, GenericUtil, HWM, MySQLConnection, MySQLLibConnection, adapter, logger, mysql, once, path, prependListener, _,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  mysql = require('mysql');

  MySQLLibConnection = require('mysql/lib/Connection');

  ConnectionConfig = require('mysql/lib/ConnectionConfig');

  prependListener = require('prepend-listener');

  once = require('once');

  _ = require('lodash');

  path = require('path');

  GenericUtil = require('../GenericUtil');

  HWM = Math.pow(2, 7);

  logger = log4js.getLogger('MySQLAdapter');

  adapter = {
    name: 'mysql',
    createQuery: function(text, values, callback) {
      var emitClose, hasError, query, result, stream;
      if (typeof callback === 'undefined' && typeof values === 'function') {
        callback = values;
        values = void 0;
      }
      values = values || [];
      query = mysql.createQuery(text, values);
      stream = query.stream({
        highWaterMark: HWM
      });
      emitClose = once(stream.emit.bind(stream, 'close'));
      prependListener(query, 'end', emitClose);
      stream.query = query;
      stream.text = text;
      stream.values = values;
      stream.callback = callback;
      if (typeof callback === 'function') {
        result = {
          rows: [],
          rowCount: 0,
          lastInsertId: 0,
          fields: null,
          fieldCount: 0
        };
        hasError = false;
        stream.on('error', function(err) {
          emitClose();
          hasError = true;
          this.callback(err);
        });
        stream.on('fields', function(fields) {
          result.fields = fields;
        });
        stream.on('data', function(row) {
          if (row.constructor.name === 'OkPacket') {
            result.fieldCount = row.fieldCount;
            result.affectedRows = row.affectedRows;
            result.changedRows = row.changedRows;
            result.lastInsertId = row.insertId;
          } else {
            ++result.rowCount;
            result.rows.push(row);
          }
        });
        stream.on('end', function() {
          if (!hasError) {
            this.callback(null, result);
          }
        });
      }
      stream.once('end', function() {
        delete this.query;
      });
      return stream;
    },
    createConnection: function(options, callback) {
      var client;
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      client = new MySQLConnection(options);
      return client.connect(function(err) {
        if (err) {
          return callback(err);
        }
        return callback(err, client);
      });
    }
  };

  MySQLConnection = (function(_super) {
    __extends(MySQLConnection, _super);

    MySQLConnection.prototype.adapter = adapter;

    function MySQLConnection(options) {
      this.options = _.clone(options);
      MySQLConnection.__super__.constructor.call(this, {
        config: new ConnectionConfig(options)
      });
    }

    MySQLConnection.prototype.query = function(query, params, callback) {
      var stream;
      stream = adapter.createQuery(query, params, callback);
      MySQLConnection.__super__.query.call(this, stream.query);
      return stream;
    };

    MySQLConnection.prototype.stream = function(query, params, callback, done) {
      var hasError, result, stream;
      if (arguments.length === 3) {
        done = callback;
        callback = params;
        params = [];
      }
      if (!(params instanceof Array)) {
        params = [];
      }
      if (typeof done !== 'function') {
        done = (function() {});
      }
      stream = MySQLLibConnection.prototype.query.call(this, query, params).stream({
        highWaterMark: HWM
      });
      hasError = false;
      result = {
        rowCount: 0
      };
      stream.once('error', function(err) {
        hasError = err;
        done(err);
      });
      stream.on('fields', function(fields) {
        result.fields = fields;
      });
      stream.on('data', function(row) {
        if (row.constructor.name === 'OkPacket') {
          result.fieldCount = row.fieldCount;
          result.affectedRows = row.affectedRows;
          result.changedRows = row.changedRows;
          result.lastInsertId = row.insertId;
        } else {
          ++result.rowCount;
          callback(row);
        }
      });
      stream.once('end', function() {
        if (!hasError) {
          done(void 0, result);
        }
      });
      return stream;
    };

    return MySQLConnection;

  })(MySQLLibConnection);

  _.extend(adapter, require('./common'));

  _.extend(adapter, {
    escape: function(value) {
      return MySQLConnection.prototype.escape.call({
        config: {}
      }, value);
    },
    escapeId: MySQLConnection.prototype.escapeId
  });

  module.exports = adapter;

}).call(this);
