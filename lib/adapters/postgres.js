// Generated by CoffeeScript 1.9.3
var PostgresQueryStream, QueryStream, _, adapter, common, logger, pg,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

pg = require('pg');

QueryStream = require('pg-query-stream');

_ = require('lodash');

logger = log4js.getLogger('PostgresAdapter');

common = require('./common');

_.extend(adapter, common);

adapter = module.exports;

_.extend(adapter, common);

pg.Client.prototype.stream = function(query, params, callback, done) {
  var hasError, result, stream;
  if (arguments.length === 3) {
    done = callback;
    callback = params;
    params = [];
  }
  if (!(params instanceof Array)) {
    params = [];
  }
  if (typeof done !== 'function') {
    done = (function() {});
  }
  query = new PostgresQueryStream(query);
  stream = pg.Client.prototype.query.call(this, query, params);
  hasError = false;
  result = {
    rowCount: 0
  };
  stream.once('error', function(err) {
    hasError = err;
    done(err);
  });
  stream.on('fields', function(fields) {
    result.fields = fields;
  });
  stream.on('data', function() {
    ++result.rowCount;
    callback.apply(null, arguments);
  });
  stream.once('end', function() {
    if (!hasError) {
      done(null, result);
    }
  });
  return stream;
};

PostgresQueryStream = (function(superClass) {
  extend(PostgresQueryStream, superClass);

  function PostgresQueryStream() {
    return PostgresQueryStream.__super__.constructor.apply(this, arguments);
  }

  PostgresQueryStream.prototype.handleRowDescription = function(message) {
    QueryStream.prototype.handleRowDescription.call(this, message);
    this.emit('fields', message.fields);
  };

  PostgresQueryStream.prototype.handleError = function(err) {
    this.push(null);
    return PostgresQueryStream.__super__.handleError.apply(this, arguments);
  };

  return PostgresQueryStream;

})(QueryStream);

_.extend(adapter, {
  name: 'postgres',
  createConnection: function(options, callback) {
    var client;
    if (typeof callback !== 'function') {
      callback = (function() {});
    }
    client = new pg.Client(options);
    client.connect(function(err) {
      if (err) {
        return callback(err, null);
      }
      client.query("set schema '" + options.schema + "'", function(err, result) {
        callback(err, client);
      });
    });
    return client;
  },
  escape: function(value) {
    var type;
    type = typeof value;
    if (type === 'number') {
      return value;
    }
    if (type === 'boolean') {
      if (value) {
        return 'TRUE';
      } else {
        return 'FALSE';
      }
    }
    return pg.Client.prototype.escapeLiteral(value);
  },
  escapeId: pg.Client.prototype.escapeIdentifier,
  escapeSearch: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.POSTGRES].search);
  },
  escapeBeginWith: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.POSTGRES].begin);
  },
  escapeEndWith: function(value) {
    return common._escape(value, common._escapeConfigs[common.CONSTANTS.POSTGRES].end);
  }
});
