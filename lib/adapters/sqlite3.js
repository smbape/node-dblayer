// Generated by CoffeeScript 1.9.2
(function() {
  var ArrayStream, EventEmitter, GenericUtil, MODES, SQLite3Connection, SQLite3Query, SQLite3Stream, _, adapter, log4js, logger, path, sqlite3,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  path = require('path');

  _ = require('lodash');

  GenericUtil = require('../GenericUtil');

  sqlite3 = require('sqlite3');

  EventEmitter = require('events').EventEmitter;

  log4js = global.log4js || (global.log4js = require('log4js'));

  logger = log4js.getLogger('SQLite3Adapter');

  MODES = {
    READ: [Math.pow(2, 0), sqlite3.OPEN_READONLY],
    WRITE: [Math.pow(2, 1), sqlite3.OPEN_READWRITE],
    CREATE: [Math.pow(2, 2), sqlite3.OPEN_CREATE]
  };

  adapter = module.exports;

  _.extend(adapter, {
    name: 'sqlite3',
    createConnection: function(options, callback) {
      var database, filename, mode, name, opt_mode, value;
      database = options.database || '';
      if (options.host) {
        filename = path.join(options.host, database);
      } else {
        filename = database;
      }
      if (options.workdir) {
        filename = path.join(options.workdir, filename);
      }
      if (!filename || filename === '/:memory') {
        filename = ':memory:';
      }
      if (!isNaN(options.mode)) {
        mode = 0;
        opt_mode = parseInt(options.mode, 10);
        for (name in MODES) {
          value = MODES[name];
          if (value[0] === (value[0] & opt_mode)) {
            mode |= value[1];
          }
        }
      }
      if (!mode) {
        mode = sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE;
      }
      return new SQLite3Connection(filename, mode, callback);
    }
  }, require('./common'), GenericUtil.sql);

  SQLite3Connection = (function(superClass) {
    extend(SQLite3Connection, superClass);

    SQLite3Connection.prototype.adapter = adapter;

    function SQLite3Connection(filename, mode, callback) {
      SQLite3Connection.__super__.constructor.call(this);
      logger.debug('SQLite3Connection', filename);
      this.db = new sqlite3.Database(filename, mode);
      this.db.serialize();
      this.db.on('error', (function(_this) {
        return function(err) {
          _this.emit('error', err);
        };
      })(this));
      this.db.once('error', callback);
      this.db.once('open', (function(_this) {
        return function() {
          _this.db.removeListener('error', callback);
          callback(null, _this);
        };
      })(this));
      this.db.on('close', (function(_this) {
        return function() {
          _this.emit('end');
        };
      })(this));
      return;
    }

    SQLite3Connection.prototype.query = function() {
      var query;
      query = new SQLite3Query(arguments);
      query.execute(this.db);
      return query;
    };

    SQLite3Connection.prototype.stream = function(query, values, callback, done) {
      var stream;
      stream = new SQLite3Stream(arguments);
      stream.execute(this.db);
      return stream;
    };

    SQLite3Connection.prototype.end = function() {
      logger.debug('close connection');
      this.db.close();
    };

    return SQLite3Connection;

  })(EventEmitter);

  SQLite3Query = (function(superClass) {
    extend(SQLite3Query, superClass);

    function SQLite3Query(args) {
      this.init.apply(this, args);
    }

    SQLite3Query.prototype.init = function(text, values, callback) {
      this.text = text;
      if (Array.isArray(values)) {
        this.values = values;
      } else {
        this.values = [];
        if (arguments.length === 2 && 'function' === typeof values) {
          callback = values;
        }
      }
      this.callback = 'function' === typeof callback ? callback : function() {};
    };

    SQLite3Query.prototype.execute = function(db) {
      var callback, hasError, query, result, values;
      query = this.text;
      values = this.values;
      callback = this.callback;
      if (query.match(/^\s*insert\s+/i)) {
        db.run(query, values, function(err) {
          if (err) {
            return callback(err);
          }
          callback(err, {
            lastInsertId: this.lastID
          });
        });
        return;
      }
      if (query.match(/^\s*(?:update|delete)\s+/i)) {
        db.run(query, values, function(err) {
          if (err) {
            return callback(err);
          }
          callback(err, {
            changedRows: this.changes,
            affectedRows: this.changes
          });
        });
        return;
      }
      result = {
        rows: []
      };
      hasError = false;
      db.each(query, values, function(err, row) {
        if (err) {
          if (!hasError) {
            hasError = true;
            callback(err);
          }
          return;
        }
        result.rows.push(row);
      }, function(err, rowCount) {
        if (hasError) {
          return;
        }
        if (err) {
          return callback(err);
        }
        result.rowCount = rowCount;
        if (rowCount > 0) {
          result.fields = Object.keys(result.rows[0]).map(function(name) {
            return {
              name: name
            };
          });
        } else {
          result.fields = [];
        }
        callback(err, result);
      });
    };

    return SQLite3Query;

  })(EventEmitter);

  ArrayStream = require('sm-array-stream');

  SQLite3Stream = (function(superClass) {
    extend(SQLite3Stream, superClass);

    function SQLite3Stream(args) {
      SQLite3Stream.__super__.constructor.call(this, [], {
        duplex: true
      });
      this.init.apply(this, args);
    }

    SQLite3Stream.prototype.init = function(text, values, callback, done) {
      this.text = text;
      if (Array.isArray(values)) {
        this.values = values;
      } else {
        this.values = [];
        if (arguments.length === 2) {
          if ('function' === typeof values) {
            done = values;
          }
        } else if (arguments.length === 3) {
          if ('function' === typeof callback) {
            done = callback;
          }
          if ('function' === typeof values) {
            callback = values;
          }
        }
      }
      this.callback = 'function' === typeof callback ? callback : function() {};
      this.done = 'function' === typeof done ? done : function() {};
    };

    SQLite3Stream.prototype.execute = function(db) {
      var done, hasError, query, result, values;
      query = this.text;
      values = this.values;
      done = this.done;
      result = {};
      hasError = false;
      this.on('data', this.callback);
      this.once('error', function(err) {
        hasError = true;
        done(err);
      });
      this.once('end', (function(_this) {
        return function() {
          _this.removeListener('data', _this.callback);
          if (hasError) {
            return;
          }
          if (!result.fields) {
            result.fields = [];
          }
          done(null, result);
        };
      })(this));
      db.each(query, values, (function(_this) {
        return function(err, row) {
          if (err) {
            _this.emit('error', err);
            return;
          }
          if (!result.fields) {
            result.fields = Object.keys(row).map(function(name) {
              return {
                name: name
              };
            });
            _this.emit('fields', result.fields);
          }
          _this.write(row, 'item');
        };
      })(this), (function(_this) {
        return function(err, rowCount) {
          _this.end();
          if (err) {
            _this.emit('error', err);
          }
        };
      })(this));
    };

    return SQLite3Stream;

  })(ArrayStream);

}).call(this);
