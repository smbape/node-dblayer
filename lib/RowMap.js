// Generated by CoffeeScript 1.9.0
(function() {
  var GenericUtil, JOIN_FUNC, RowMap, STATIC, fieldPattern, fieldPatternTest, log4js, logger, path, squel, _, _coerce, _createModel, _createPlainObject, _getModelValue, _getPlainObjectValue, _handleRead, _readFields, _replaceField, _setModelValue, _setPlainObjectValue,
    __slice = [].slice;

  _ = require('lodash');

  path = require('path');

  GenericUtil = require('./GenericUtil');

  log4js = global.log4js || (global.log4js = require('log4js'));

  logger = log4js.getLogger('RowMap');

  squel = require('squel');

  STATIC = {
    PROP_SEP: ':',
    FIELD_CHAR_BEGIN: '{',
    FIELD_CHAR_END: '}',
    ROOT: 'root'
  };

  JOIN_FUNC = {
    inner: 'join',
    outer: 'outer_join',
    left: 'left_join',
    right: 'right_join'
  };

  _handleRead = function(value, propDef) {
    if (typeof propDef.read === 'function') {
      value = propDef.read(value);
    }
    return value;
  };

  _createModel = function(className) {
    var Ctor, definition;
    if (className == null) {
      className = this.className;
    }
    definition = this.manager.getDefinition(className);
    Ctor = definition.ctor;
    return new Ctor();
  };

  _setModelValue = function(model, prop, value, propDef) {
    return model.set(prop, _handleRead(value, propDef));
  };

  _getModelValue = function(model, prop) {
    return model.get(prop);
  };

  _createPlainObject = function(className) {
    return {};
  };

  _setPlainObjectValue = function(model, prop, value, propDef) {
    return model[prop] = _handleRead(value, propDef);
  };

  _getPlainObjectValue = function(model, prop) {
    return model[prop];
  };

  module.exports = RowMap = (function() {
    RowMap.prototype["static"] = {
      LIMIT: 500
    };

    function RowMap(_at_className, _at_manager, _at_options) {
      this.className = _at_className;
      this.manager = _at_manager;
      this.options = _at_options != null ? _at_options : {};
      _.extend(this, {
        _infos: {},
        _tableAliases: {},
        _tabId: 0,
        _columnAliases: {},
        _colId: 0,
        _tables: {},
        _mixins: {},
        _joining: {}
      });
      this._initialize();
      this._processJoins();
      this._processFields();
      this._processOptions();
    }

    RowMap.prototype._initialize = function() {
      var connector;
      if (this.options.type === 'json' || this.options.count) {
        this._setValue = _setPlainObjectValue;
        this._getValue = _getPlainObjectValue;
        this._create = _createPlainObject;
      } else {
        this._setValue = _setModelValue;
        this._getValue = _getModelValue;
        this._create = _createModel;
      }
      connector = this.options.connector;
      if (connector) {
        this.escapeId = function(str) {
          return connector.escapeId(str);
        };
      } else {
        this.escapeId = function(str) {
          return str;
        };
      }
      this._initRootElement(this.className, this._getUniqueId());
    };

    RowMap.prototype._initRootElement = function(className, id, options) {
      var condition, definition, err, hasJoin, select, table, tableAlias;
      if (options == null) {
        options = {};
      }
      if (this._tables.hasOwnProperty(id)) {
        return;
      }
      if (!className) {
        if (!this.options.hasOwnProperty('join') || !this.options.join.hasOwnProperty(id)) {
          err = new Error(id + " was not found in any join definitions");
          err.code = 'TABLE_UNDEF';
          throw err;
        }
        className = this.options.join[id].entity;
        options = this.options.join[id];
      }
      definition = this.manager.getDefinition(className);
      table = definition.table;
      tableAlias = this._uniqTabAlias();
      select = this.options.select;
      if (options.hasOwnProperty('condition')) {
        this._tables[id] = tableAlias;
        this._infos[id] = {
          className: className
        };
        if (this._joining.hasOwnProperty(id)) {
          err = new Error(id + " is already being join. Look at stack to find the circular reference");
          err.code = 'CIRCULAR_REF';
          throw err;
        }
        this._joining[id] = true;
        condition = _readFields.call(this, options.condition);
        if (JOIN_FUNC.hasOwnProperty(options.type)) {
          hasJoin = JOIN_FUNC[options.type];
        } else {
          hasJoin = JOIN_FUNC.inner;
        }
        select[hasJoin](this.escapeId(table), tableAlias, condition);
        delete this._joining[id];
        this._infos[id].hasJoin = hasJoin;
      } else if (_.isEmpty(this._tables)) {
        select.from(this.escapeId(table), tableAlias);
        this._tables[id] = tableAlias;
        this._infos[id] = {
          className: className,
          hasJoin: JOIN_FUNC.inner
        };
        this._rootInfo = this._infos[id];
      } else {
        err = new Error(id + " has no joining condition");
        err.code = 'JOIN_COND';
        throw err;
      }
    };

    RowMap.prototype._processJoins = function() {
      var alias, field, fields, join, joinDef, _i, _len;
      join = this.options.join;
      if (_.isEmpty(join)) {
        return;
      }
      for (alias in join) {
        joinDef = join[alias];
        this._initRootElement(joinDef.entity, alias, joinDef);
        fields = this._sanitizeFields(joinDef.fields);
        if (fields.length > 0) {
          this._rootInfo.properties = this._rootInfo.properties || {};
          this._rootInfo.properties[alias] = true;
          this._infos[alias].attribute = alias;
          if (!this.options.count) {
            for (_i = 0, _len = fields.length; _i < _len; _i++) {
              field = fields[_i];
              this._setField(this._getUniqueId(field, alias), true);
            }
          }
        }
      }
    };

    RowMap.prototype._processFields = function() {
      var field, fields, _i, _len;
      if (this.options.count) {
        this._selectCount();
        return;
      }
      fields = this._sanitizeFields(this.options.fields, ['*']);
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        field = fields[_i];
        this._setField(field);
      }
    };

    RowMap.prototype._processOptions = function() {
      var block, err, opt, option, select, _i, _j, _len, _len1, _ref;
      select = this.options.select;
      _ref = ['where', 'group', 'having', 'order', 'limit', 'offset'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        option = this.options[block];
        if (/^(?:string|boolean|number)$/.test(typeof option)) {
          option = [option];
        } else if (block === 'limit') {
          option = [this["static"].LIMIT];
        } else if (_.isEmpty(option)) {
          continue;
        }
        if (!(option instanceof Array)) {
          err = new Error("[" + this.className + "]: " + block + " can only be a string or an array");
          err.code = block.toUpperCase();
          throw err;
        }
        if (block === 'limit' && option[0] < 0) {
          continue;
        }
        for (_j = 0, _len1 = option.length; _j < _len1; _j++) {
          opt = option[_j];
          _readFields.call(this, opt, select, block);
        }
      }
    };

    RowMap.prototype._getSetColumn = function(field) {
      var allAncestors, ancestors, id, index, info, prop, _i, _len;
      allAncestors = this._getAncestors(field);
      ancestors = [];
      for (index = _i = 0, _len = allAncestors.length; _i < _len; index = ++_i) {
        prop = allAncestors[index];
        ancestors.push(prop);
        if (index === 0) {
          this._initRootElement(null, prop);
          continue;
        }
        id = this._getUniqueId(null, ancestors);
        this._getSetInfo(id);
        if (index === allAncestors.length - 1) {
          continue;
        }
        this._joinProp(id);
        info = this._getInfo(id);
        if (info.hasOwnProperty('properties') && !info.setted) {
          for (prop in info.properties) {
            this._setField(prop, true);
          }
          info.setted = true;
        }
      }
      return this._getColumn(id);
    };

    RowMap.prototype._sanitizeFields = function(fields, defaultValue) {
      var err;
      if (typeof fields === 'undefined') {
        fields = defaultValue || [];
      }
      if (typeof fields === 'string') {
        fields = [fields];
      }
      if (!(fields instanceof Array)) {
        err = new Error("[" + this.className + "]: fields can only be a string or an array");
        err.code = 'FIELDS';
        throw err;
      }
      if (fields.length === 0) {
        return [];
      }
      return fields;
    };

    RowMap.prototype._setField = function(field, isFull) {
      var allAncestors, ancestors, id, index, info, parentInfo, prop, _i, _len;
      allAncestors = this._getAncestors(field, isFull);
      ancestors = [];
      for (index = _i = 0, _len = allAncestors.length; _i < _len; index = ++_i) {
        prop = allAncestors[index];
        if (index === allAncestors.length - 1) {
          this._selectProp(prop, ancestors);
          continue;
        }
        parentInfo = info;
        ancestors.push(prop);
        id = this._getUniqueId(null, ancestors);
        info = this._getSetInfo(id);
        if (parentInfo) {
          parentInfo.properties = parentInfo.properties || {};
          this._set(parentInfo.properties, id, true);
        }
        this._joinProp(id);
      }
    };

    RowMap.prototype._selectCount = function() {
      var ancestors, column, columnAlias, id, info, parentInfo, prop;
      prop = 'count';
      ancestors = [STATIC.ROOT];
      id = this._getUniqueId(prop, ancestors);
      info = this._getSetInfo(id, true);
      this._set(info, 'read', function(value) {
        return parseInt(value, 10);
      });
      if (info.hasOwnProperty('field')) {
        return;
      }
      column = 'count(1)';
      columnAlias = this._uniqColAlias();
      this.options.select.field(column, columnAlias);
      this._set(info, 'field', columnAlias);
      parentInfo = this._getInfo(this._getUniqueId(null, ancestors));
      parentInfo.properties = parentInfo.properties || {};
      this._set(parentInfo.properties, id, true);
    };

    RowMap.prototype._selectProp = function(prop, ancestors) {
      var column, columnAlias, definition, id, info, parentInfo, parentProp, properties;
      if (prop === '*') {
        id = this._getUniqueId(null, ancestors);
        info = this._getInfo(id);
        this._set(info, 'selectAll', true);
        definition = this.manager.getDefinition(info.className);
        for (prop in definition.availableProperties) {
          this._setField(this._getUniqueId(prop, ancestors), true);
        }
        return;
      }
      id = this._getUniqueId(prop, ancestors);
      info = this._getSetInfo(id);
      if (info.hasOwnProperty('field')) {
        return;
      }
      column = this._getColumn(id);
      columnAlias = this._uniqColAlias();
      this.options.select.field(column, columnAlias);
      this._set(info, 'field', columnAlias);
      parentInfo = this._getInfo(this._getUniqueId(null, ancestors));
      parentInfo.properties = parentInfo.properties || {};
      this._set(parentInfo.properties, id, true);
      this._set(info, 'selectAll', parentInfo.selectAll);
      if (info.selectAll && info.hasOwnProperty('className') && !info.hasOwnProperty('selectedAll')) {
        parentProp = prop;
        properties = this.manager.getDefinition(info.className).availableProperties;
        info.properties = {};
        for (prop in properties) {
          this._set(info.properties, this._getUniqueId(prop, parentProp, ancestors), true);
        }
        info.selectedAll = true;
      }
    };

    RowMap.prototype._joinProp = function(id, hasJoin) {
      var column, connector, err, idColumn, info, propDef, select, table, tableAlias;
      info = this._getInfo(id);
      if (info.hasOwnProperty('hasJoin')) {
        return;
      }
      if (!info.hasOwnProperty('className')) {
        err = new Error("[" + id + "] is not a class");
        err.code = 'FIELDS';
        throw err;
      }
      connector = this.options.connector;
      column = this._getColumn(id);
      propDef = this.manager.getDefinition(info.className);
      idColumn = connector.escapeId(propDef.id.column);
      table = propDef.table;
      tableAlias = this._uniqTabAlias();
      select = this.options.select;
      if (typeof hasJoin === 'undefined') {
        hasJoin = JOIN_FUNC.left;
      }
      select[hasJoin](connector.escapeId(table), tableAlias, connector.escapeId(tableAlias) + '.' + idColumn + ' = ' + column);
      this._tables[id] = tableAlias;
      this._set(info, 'hasJoin', hasJoin);
    };

    RowMap.prototype._getPropAncestors = function(id) {
      var ancestors, prop;
      ancestors = id.split(STATIC.PROP_SEP);
      prop = ancestors.pop();
      return [prop, ancestors];
    };

    RowMap.prototype._getSetInfo = function(id, asIs) {
      var ancestors, availableProperty, definition, info, parentInfo, prop, propDef, _ref;
      info = this._getInfo(id);
      if (info) {
        return info;
      }
      _ref = this._getPropAncestors(id), prop = _ref[0], ancestors = _ref[1];
      if (asIs) {
        return this._setInfo(id, {
          attribute: prop
        });
      }
      parentInfo = this._getInfo(this._getUniqueId(null, ancestors));
      definition = this.manager.getDefinition(parentInfo.className);
      availableProperty = definition.availableProperties[prop];
      if ('undefined' === typeof availableProperty) {
        throw new Error("Property '" + prop + "' is not defined for '" + parentInfo.className + "'");
      }
      propDef = availableProperty.definition;
      info = {
        attribute: prop
      };
      if (propDef.hasOwnProperty('className') && propDef !== definition.id) {
        this._set(info, 'className', propDef.className);
      }
      if (propDef.hasOwnProperty('handlers') && propDef.handlers.hasOwnProperty('read')) {
        this._set(info, 'read', propDef.handlers.read);
      }
      return this._setInfo(id, info);
    };

    RowMap.prototype._getColumn = function(id) {
      var ancestors, availableProperty, className, connector, idColumn, info, joinColumn, joinFunc, mixin, mixinDef, mixinId, parentId, parentInfo, prop, propDef, select, table, tableAlias, _ref;
      info = this._getInfo(id);
      if (info.hasOwnProperty('column')) {
        return info.column;
      }
      _ref = this._getPropAncestors(id), prop = _ref[0], ancestors = _ref[1];
      parentId = this._getUniqueId(null, ancestors);
      availableProperty = this._getAvailableProperty(prop, ancestors, id);
      connector = this.options.connector;
      select = this.options.select;
      tableAlias = this._tables[parentId];
      if (availableProperty.mixin) {
        parentInfo = this._getInfo(parentId);
        if (parentInfo.hasJoin === JOIN_FUNC.left) {
          joinFunc = JOIN_FUNC.left;
        } else {
          joinFunc = JOIN_FUNC.inner;
        }
      }
      while (mixin = availableProperty.mixin) {
        className = mixin.className;
        mixinDef = this.manager.getDefinition(className);
        mixinId = parentId + STATIC.PROP_SEP + className;
        if (typeof this._mixins[mixinId] === 'undefined') {
          idColumn = connector.escapeId(mixinDef.id.column);
          joinColumn = connector.escapeId(tableAlias) + '.' + connector.escapeId(mixin.column);
          table = mixinDef.table;
          tableAlias = this._uniqTabAlias();
          select[joinFunc](connector.escapeId(table), tableAlias, connector.escapeId(tableAlias) + '.' + idColumn + ' = ' + joinColumn);
          this._mixins[mixinId] = {
            tableAlias: tableAlias
          };
        } else {
          tableAlias = this._mixins[mixinId].tableAlias;
        }
        availableProperty = mixinDef.availableProperties[prop];
      }
      propDef = availableProperty.definition;
      this._set(info, 'column', connector.escapeId(tableAlias) + '.' + connector.escapeId(propDef.column));
      return info.column;
    };

    RowMap.prototype.initModel = function(row, model, tasks) {
      var id, info, prop;
      if (tasks == null) {
        tasks = [];
      }
      if (!model) {
        model = this._create();
      }
      id = this._getUniqueId();
      info = this._getInfo(id);
      for (prop in info.properties) {
        this._initValue(prop, row, model, tasks);
      }
      return model;
    };

    RowMap.prototype._initValue = function(id, row, model, tasks) {
      var childIdProp, childModel, childProp, info, prop, propClassName, value;
      info = this._getInfo(id);
      value = row[info.field];
      prop = info.attribute;
      if (value === null || !info.hasOwnProperty('className')) {
        this._setValue(model, prop, value, info);
        return model;
      }
      propClassName = info.className;
      childModel = this._getValue(model, prop);
      if (!GenericUtil.isObject(childModel)) {
        childModel = this._create(propClassName);
        this._setValue(model, prop, childModel, info);
      }
      if (info.hasOwnProperty('hasJoin')) {
        for (childProp in info.properties) {
          this._initValue(childProp, row, childModel, tasks);
        }
        childIdProp = this.manager.getIdName(propClassName);
        if (null === this._getValue(childModel, childIdProp)) {
          this._setValue(model, prop, null, info);
        }
      } else {
        tasks.push({
          className: propClassName,
          options: {
            type: this.options.type,
            models: [childModel],
            where: STATIC.FIELD_CHAR_BEGIN + this.manager.getIdName(propClassName) + STATIC.FIELD_CHAR_END + ' = ' + value,
            limit: 2
          }
        });
      }
      return model;
    };

    RowMap.prototype._getUniqueId = function() {
      var ancestor, ancestors, res, _i, _len;
      ancestors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (ancestors.length === 0) {
        return STATIC.ROOT;
      }
      res = [];
      for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
        ancestor = ancestors[_i];
        if (typeof ancestor === 'string') {
          res.unshift(ancestor);
        } else if (ancestor instanceof Array) {
          res.unshift(ancestor.join(STATIC.PROP_SEP));
        }
      }
      return res.join(STATIC.PROP_SEP);
    };

    RowMap.prototype._uniqTabAlias = function() {
      var tableAlias;
      tableAlias = 'TBL_' + this._tabId++;
      this._tableAliases[tableAlias] = true;
      return tableAlias;
    };

    RowMap.prototype._uniqColAlias = function() {
      var columnAlias;
      columnAlias = 'COL_' + this._colId++;
      this._columnAliases[columnAlias] = true;
      return columnAlias;
    };

    RowMap.prototype._set = function(obj, key, value) {
      return obj[key] = value;
    };

    RowMap.prototype._getInfo = function(id) {
      return this._infos[id];
    };

    RowMap.prototype._setInfo = function(id, extra) {
      var info;
      info = this._infos[id];
      if (info) {
        _.extend(info, extra);
      } else {
        this._infos[id] = extra;
      }
      return this._infos[id];
    };

    RowMap.prototype._getAvailableProperty = function(prop, ancestors) {
      var definition, id, info;
      id = this._getUniqueId(null, ancestors);
      info = this._getInfo(id);
      definition = this.manager.getDefinition(info.className);
      if (prop) {
        return definition.availableProperties[prop];
      } else {
        return definition;
      }
    };

    RowMap.prototype._getAncestors = function(field, isFull) {
      var ancestors, err;
      if (typeof field === 'string') {
        if (isFull) {
          ancestors = field.split(STATIC.PROP_SEP);
        } else if (/^[^,]+,[^,]+$/.test(field)) {
          field = field.split(/\s*,\s*/);
          ancestors = field[1].split(STATIC.PROP_SEP);
          ancestors.unshift(field[0]);
        } else {
          ancestors = field.split(STATIC.PROP_SEP);
          ancestors.unshift(STATIC.ROOT);
        }
      } else if (!(field instanceof Array)) {
        err = new Error("Field '" + field + "' is not an Array nor a string");
        err.code = 'FIELDS';
        throw err;
      }
      return ancestors || [];
    };

    RowMap.prototype.parse = function(query) {
      return _replaceField(query, (function(_this) {
        return function(field) {
          return _this._getSetColumn(field);
        };
      })(this));
    };

    return RowMap;

  })();

  fieldPatternTest = new RegExp('(?:[\'"`]|\\' + STATIC.FIELD_CHAR_BEGIN + '(?:[^\\' + STATIC.FIELD_CHAR_BEGIN + '\\' + STATIC.FIELD_CHAR_END + ']+)\\' + STATIC.FIELD_CHAR_END + ')');

  fieldPattern = new RegExp('(?:([\'"`])|\\' + STATIC.FIELD_CHAR_BEGIN + '([^\\' + STATIC.FIELD_CHAR_BEGIN + '\\' + STATIC.FIELD_CHAR_END + ']+)\\' + STATIC.FIELD_CHAR_END + ')', 'g');

  _replaceField = function(str, callback) {
    var ignoreUntil;
    ignoreUntil = false;
    return str.replace(fieldPattern, (function(_this) {
      return function(match, group0, group1, index, str) {
        if (!ignoreUntil) {
          if (GenericUtil.notEmptyString(group0)) {
            ignoreUntil = group0;
          } else {
            return callback(group1);
          }
        } else if (ignoreUntil === match) {
          ignoreUntil = false;
        }
        return match;
      };
    })(this));
  };

  _readFields = function(values, select, block) {
    var ret, val, value, _i, _j, _len, _len1;
    if (values instanceof Array) {
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        if (Array.isArray(value)) {
          for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
            val = value[_j];
            _coerce.call(this, val);
          }
        } else {
          _coerce.call(this, value);
        }
      }
      if (select) {
        select[block].apply(select, values);
      }
    } else {
      ret = _coerce.call(this, values);
      if (select) {
        select[block](values);
      }
    }
    return ret || values;
  };

  _coerce = function(str) {
    if (str instanceof squel.cls.Expression) {
      return _replaceField(str.toString(), (function(_this) {
        return function(field) {
          return _this._getSetColumn(field);
        };
      })(this));
    } else if ('string' === typeof str) {
      return _replaceField(str.toString(), (function(_this) {
        return function(field) {
          return _this._getSetColumn(field);
        };
      })(this));
    }
    return str;
  };

}).call(this);
