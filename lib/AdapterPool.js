// Generated by CoffeeScript 1.9.2
var AdapterPool, GenericPool, GenericUtil, PriorityQueue, _, defaultOptions, internal, levelMap, log4js, logger, path;

log4js = global.log4js || (global.log4js = require('log4js'));

logger = log4js.getLogger('AdapterPool');

internal = {};

internal.adapters = {};

internal.getAdapter = function(options) {

  /* istanbul ignore else */
  var adapter, err;
  if (typeof options.adapter === 'string') {
    adapter = internal.adapters[options.adapter];
    if (typeof adapter === 'undefined') {
      adapter = require(path.join(__dirname, 'adapters', options.adapter));
      internal.adapters[options.adapter] = adapter;
    }
  }
  if (typeof adapter.createConnection !== 'function') {
    err = new Error('adapter object has no method createConnection');
    err.code = 'BAD_ADAPTER';
    throw err;
  }
  return adapter;
};

_ = require('lodash');

path = require('path');

GenericUtil = require('./GenericUtil');

GenericPool = require('../generic-pool');

defaultOptions = {
  minConnection: 0,
  maxConnection: 1,
  idleTimeout: 10 * 60
};

levelMap = {
  error: 'error',
  warn: 'warn',
  info: 'debug',
  verbose: 'trace'
};

PriorityQueue = (function() {
  function PriorityQueue(size) {
    var i, j, ref;
    this._size = Math.max(+size | 0, 1);
    this._slots = [];
    this._total = null;
    for (i = j = 0, ref = this._size; j < ref; i = j += 1) {
      this._slots.push([]);
    }
  }

  PriorityQueue.prototype.size = function() {
    var j, len, ref, slot;
    if (this._total === null) {
      this._total = 0;
      ref = this._slots;
      for (j = 0, len = ref.length; j < len; j++) {
        slot = ref[j];
        this._total += slot.length;
      }
    }
    return this._total;
  };

  PriorityQueue.prototype.enqueue = function(obj, priority) {
    var priorityOrig;
    priority = priority && +priority | 0 || 0;
    this._total = null;
    if (priority) {
      priorityOrig = priority;
      if (priority < 0 || priority >= this._size) {
        priority = size - 1;
      }
      logger.error("invalid priority: " + priorityOrig + " must be between 0 and " + priority);
    }
    this._slots[priority].push(obj);
  };

  PriorityQueue.prototype.dequeue = function(callback) {
    var j, len, ref, slot;
    this._total = null;
    ref = this._slots;
    for (j = 0, len = ref.length; j < len; j++) {
      slot = ref[j];
      if (slot.length) {
        return slot.shift();
      }
    }
    return null;
  };

  return PriorityQueue;

})();

module.exports = AdapterPool = (function() {
  function AdapterPool(connectionUrl, options, next) {
    var auth, err, except, j, k, key, len, len1, parsed, pool, prop, ref, ref1, url;
    if (arguments.length === 1) {
      if (connectionUrl !== null && 'object' === typeof connectionUrl) {
        options = connectionUrl;
        connectionUrl = null;
      }
    } else if (arguments.length === 2) {
      if ('function' === typeof options) {
        next = options;
        options = null;
      }
      if (connectionUrl !== null && 'object' === typeof connectionUrl) {
        options = connectionUrl;
        connectionUrl = null;
      }
    }
    if (connectionUrl && typeof connectionUrl !== 'string') {
      err = new Error("'connectionUrl' must be a String");
      err.code = 'BAD_CONNECTION_URL';
      throw err;
    }
    if (options && 'object' !== typeof options) {
      err = new Error("'options' must be an object");
      err.code = 'BAD_OPTION';
      throw err;
    }
    if (connectionUrl) {
      this.connectionUrl = connectionUrl;
      url = require('url');
      parsed = url.parse(connectionUrl, true, true);
      this.options = {};
      this.options.adapter = parsed.protocol && parsed.protocol.substring(0, parsed.protocol.length - 1);
      this.options.database = parsed.pathname && parsed.pathname.substring(1);
      this.options.host = parsed.hostname;
      if (GenericUtil.isNumeric(parsed.port)) {
        this.options.port = parseInt(parsed.port, 10);
      }
      if (parsed.auth) {
        auth = parsed.auth.split(':');
        this.options.user = auth[0];
        this.options.password = auth[1];
      }
      for (key in parsed.query) {
        this.options[key] = parsed.query[key];
      }
      _.extend(this.options, options);
    } else if (options) {
      this.options = _.clone(options);
      parsed = {
        query: {}
      };
      parsed.protocol = this.options.adapter + '/';
      parsed.pathname = '/' + this.options.database;
      parsed.hostname = this.options.host;
      if (GenericUtil.isNumeric(this.options.port)) {
        parsed.port = this.options.port;
      }
      if ('string' === typeof this.options.user && this.options.user.length > 0) {
        if ('string' === typeof this.options.password && this.options.password.length > 0) {
          parsed.auth = this.options.user + ':' + this.options.password;
        } else {
          parsed.auth = this.options.user;
        }
      }
      except = ['adapter', 'database', 'port', 'user', 'password'];
      for (key in this.options) {
        if (-1 === except.indexOf(key)) {
          parsed.query[key] = this.options[key];
        }
      }
      this.connectionUrl = url.format(parsed);
    } else {
      err = new Error("Invalid arguments. Usage: options[, fn]; url[, fn]: url, options[, fn]");
      err.code = 'INVALID_ARGUMENTS';
      throw err;
    }
    if (typeof this.options.adapter !== 'string' || this.options.adapter.length === 0) {
      err = new Error('adapter must be a not empty string');
      err.code = 'BAD_ADAPTER';
      throw err;
    }
    ref = ['name'];
    for (j = 0, len = ref.length; j < len; j++) {
      prop = ref[j];
      if (typeof options.hasOwnProperty(prop)) {
        this.options[prop] = options[prop];
      }
    }
    ref1 = ['minConnection', 'maxConnection', 'idleTimeout'];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      prop = ref1[k];
      if (GenericUtil.isNumeric(this.options.maxConnection)) {
        this.options[prop] = parseInt(this.options[prop], 10);
      } else {
        this.options[prop] = defaultOptions[prop];
      }
    }
    this.adapter = internal.getAdapter(this.options);
    _.extend(this, pool = GenericPool.Pool({
      name: this.options.name,
      create: (function(_this) {
        return function(callback) {
          logger.debug(_this.options.name + " create");
          _this.adapter.createConnection(_this.options, function(err, client) {
            if (err) {
              return callback(err, null);
            }
            client.on('error', function(err) {
              logger.error('error', err);
              pool.destroy(client);
            });
            client.on('end', function(err) {
              pool.destroy(client);
            });
            callback(null, client);
          });
        };
      })(this),
      destroy: (function(_this) {
        return function(client) {
          if (client._destroying) {
            return;
          }
          logger.debug(_this.options.name + " destroy");
          client._destroying = true;
          client.end();
        };
      })(this),
      max: this.options.maxConnection,
      min: this.options.minConnection,
      idleTimeoutMillis: this.options.idleTimeout * 1000,
      log: function(str, level) {}
    }));
    if (typeof next === 'function') {
      this.check(next);
    }
    return;
  }

  AdapterPool.prototype.check = function(next) {
    if ('function' !== typeof next) {
      next = function() {};
    }
    this.acquire((function(_this) {
      return function(err, connection) {
        if (err) {
          return next(err);
        }
        _this.release(connection);
        next();
      };
    })(this));
  };

  AdapterPool.prototype.getDialect = function() {
    return this.options.adapter;
  };

  AdapterPool.prototype.createConnector = function(options) {
    var Connector;
    Connector = require('./Connector');
    return new Connector(this, options);
  };

  AdapterPool.prototype.getMaxConnection = function() {
    return this.options.maxConnection;
  };

  return AdapterPool;

})();
