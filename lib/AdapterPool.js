// Generated by CoffeeScript 1.9.2
var AdapterPool, GenericPool, GenericUtil, SemaphorePool, _, defaultOptions, internal, levelMap, log4js, logger, path, semLib,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

log4js = global.log4js || (global.log4js = require('log4js'));

logger = log4js.getLogger('AdapterPool');

internal = {};

internal.adapters = {};

internal.getAdapter = function(options) {

  /* istanbul ignore else */
  var adapter, err;
  if (typeof options.adapter === 'string') {
    adapter = internal.adapters[options.adapter];
    if (typeof adapter === 'undefined') {
      adapter = require(path.join(__dirname, 'adapters', options.adapter));
      internal.adapters[options.adapter] = adapter;
    }
  }
  if (typeof adapter.createConnection !== 'function') {
    err = new Error('adapter object has no method createConnection');
    err.code = 'BAD_ADAPTER';
    throw err;
  }
  return adapter;
};

_ = require('lodash');

path = require('path');

GenericUtil = require('./GenericUtil');

GenericPool = require('../generic-pool');

semLib = require('sem-lib');

defaultOptions = {
  minConnection: 0,
  maxConnection: 1,
  idleTimeout: 10 * 60
};

levelMap = {
  error: 'error',
  warn: 'warn',
  info: 'debug',
  verbose: 'trace'
};

SemaphorePool = (function(superClass) {
  extend(SemaphorePool, superClass);

  function SemaphorePool(options) {
    var i, j, len, len1, opt, ref, ref1;
    if (options == null) {
      options = {};
    }
    this._factory = {};
    ref = ['name', 'create', 'destroy', 'priority'];
    for (i = 0, len = ref.length; i < len; i++) {
      opt = ref[i];
      if (options.hasOwnProperty(opt)) {
        this._factory[opt] = options[opt];
      }
    }
    ref1 = ['min', 'max', 'idle'];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      opt = ref1[j];
      if (options.hasOwnProperty(opt)) {
        this._factory[opt] = parseInt(options[opt], 10);
      } else {
        this._factory[opt] = 0;
      }
    }
    SemaphorePool.__super__.constructor.call(this, this._max, true, this._priority);
    this._created = [];
    this._timers = {};
    this._avalaible = [];
    this._ensureMinimum();
  }

  SemaphorePool.prototype.getName = function() {
    return this._factory.name;
  };

  SemaphorePool.prototype.acquire = function(callback, opts) {
    if (opts == null) {
      opts = {};
    }
    return this.semTake({
      priority: opts.priority,
      num: 1,
      timeOut: opts.timeOut,
      onTimeOut: opts.onTimeOut,
      onTake: (function(_this) {
        return function() {
          var client;
          if (_this._avalaible.length === 0) {
            _this._factory.create(function(err, client) {
              if (err) {
                return callback(err);
              }
              _this._created.push(client);
              _this._removeIdle(_this._created.length - 1, client);
              callback(null, client);
            });
            return;
          }
          client = _this._avalaible.shift();
          _this._removeIdle(_this._created.indexOf(client), client);
          callback(null, client);
        };
      })(this)
    });
  };

  SemaphorePool.prototype.release = function(client) {
    var index;
    index = this._created.indexOf(client);
    if (~index) {
      this._avalaible.push(client);
      this._idle(index, client);
      return this.semGive();
    }
    return false;
  };

  SemaphorePool.prototype._idle = function(index, client) {
    if (this._factory.idle > 0) {
      if (this._factory.min === this._created.length) {
        return;
      }
      this._timers[index] = setTimeout((function(_this) {
        return function() {
          if (_this._factory.min === _this._created.length) {
            return;
          }
          _this.destroy(client);
        };
      })(this), this._factory.idle);
    }
  };

  SemaphorePool.prototype._removeIdle = function(index, client) {
    clearTimeout(this._timers[index]);
  };

  SemaphorePool.prototype.destroy = function(client) {
    var index;
    index = this._created.indexOf(client);
    if (~index) {
      this._created.splice(index, 1);
      this._factory.destroy(client);
      this._ensureMinimum();
      return true;
    }
    return false;
  };

  SemaphorePool.prototype._superDestroy = function(safe, _onDestroy) {
    return SemaphorePool.__super__.destroy.call(this, safe, _onDestroy);
  };

  SemaphorePool.prototype.destroyAll = function(safe, _onDestroy) {
    if (safe !== false) {
      this._superDestroy(true, (function(_this) {
        return function() {
          _this._onDestroy();
          if ('function' === typeof _onDestroy) {
            _onDestroy();
          }
        };
      })(this));
    } else {
      this._superDestroy(false, (function(_this) {
        return function() {
          _this._onDestroy();
          if ('function' === typeof _onDestroy) {
            _onDestroy();
          }
        };
      })(this));
    }
  };

  SemaphorePool.prototype._onDestroy = function() {
    var client, i, index, len, ref, ref1, timer;
    ref = this._created;
    for (i = 0, len = ref.length; i < len; i++) {
      client = ref[i];
      this._factory.destroy(client);
    }
    ref1 = this._timers;
    for (index in ref1) {
      timer = ref1[index];
      if (timer) {
        clearTimeout(timer);
      }
    }
    this._created.splice(0, this._created.length);
    this._avalaible.splice(0, this._avalaible.length);
  };

  SemaphorePool.prototype._ensureMinimum = function() {
    if (this._factory.min > this._created.length) {
      this.acquire(function(err, client) {
        if (err) {
          return this.emit('error', err);
        }
        this.release(client);
        this._ensureMinimum();
      });
    }
  };

  return SemaphorePool;

})(semLib.Semaphore);

module.exports = AdapterPool = (function(superClass) {
  extend(AdapterPool, superClass);

  function AdapterPool(connectionUrl, options, next) {
    var auth, err, except, i, j, key, len, len1, parsed, prop, ref, ref1, url;
    if (arguments.length === 1) {
      if (connectionUrl !== null && 'object' === typeof connectionUrl) {
        options = connectionUrl;
        connectionUrl = null;
      }
    } else if (arguments.length === 2) {
      if ('function' === typeof options) {
        next = options;
        options = null;
      }
      if (connectionUrl !== null && 'object' === typeof connectionUrl) {
        options = connectionUrl;
        connectionUrl = null;
      }
    }
    if (connectionUrl && typeof connectionUrl !== 'string') {
      err = new Error("'connectionUrl' must be a String");
      err.code = 'BAD_CONNECTION_URL';
      throw err;
    }
    if (options && 'object' !== typeof options) {
      err = new Error("'options' must be an object");
      err.code = 'BAD_OPTION';
      throw err;
    }
    if (connectionUrl) {
      this.connectionUrl = connectionUrl;
      url = require('url');
      parsed = url.parse(connectionUrl, true, true);
      this.options = {};
      this.options.adapter = parsed.protocol && parsed.protocol.substring(0, parsed.protocol.length - 1);
      this.options.database = parsed.pathname && parsed.pathname.substring(1);
      this.options.host = parsed.hostname;
      if (GenericUtil.isNumeric(parsed.port)) {
        this.options.port = parseInt(parsed.port, 10);
      }
      if (parsed.auth) {
        auth = parsed.auth.split(':');
        this.options.user = auth[0];
        this.options.password = auth[1];
      }
      for (key in parsed.query) {
        this.options[key] = parsed.query[key];
      }
      _.extend(this.options, options);
    } else if (options) {
      this.options = _.clone(options);
      parsed = {
        query: {}
      };
      parsed.protocol = this.options.adapter + '/';
      parsed.pathname = '/' + this.options.database;
      parsed.hostname = this.options.host;
      if (GenericUtil.isNumeric(this.options.port)) {
        parsed.port = this.options.port;
      }
      if ('string' === typeof this.options.user && this.options.user.length > 0) {
        if ('string' === typeof this.options.password && this.options.password.length > 0) {
          parsed.auth = this.options.user + ':' + this.options.password;
        } else {
          parsed.auth = this.options.user;
        }
      }
      except = ['adapter', 'database', 'port', 'user', 'password'];
      for (key in this.options) {
        if (-1 === except.indexOf(key)) {
          parsed.query[key] = this.options[key];
        }
      }
      this.connectionUrl = url.format(parsed);
    } else {
      err = new Error("Invalid arguments. Usage: options[, fn]; url[, fn]: url, options[, fn]");
      err.code = 'INVALID_ARGUMENTS';
      throw err;
    }
    if (typeof this.options.adapter !== 'string' || this.options.adapter.length === 0) {
      err = new Error('adapter must be a not empty string');
      err.code = 'BAD_ADAPTER';
      throw err;
    }
    ref = ['name'];
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      if (typeof options.hasOwnProperty(prop)) {
        this.options[prop] = options[prop];
      }
    }
    ref1 = ['minConnection', 'maxConnection', 'idleTimeout'];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      prop = ref1[j];
      if (GenericUtil.isNumeric(this.options.maxConnection)) {
        this.options[prop] = parseInt(this.options[prop], 10);
      } else {
        this.options[prop] = defaultOptions[prop];
      }
    }
    this.adapter = internal.getAdapter(this.options);
    AdapterPool.__super__.constructor.call(this, {
      name: this.options.name,
      create: (function(_this) {
        return function(callback) {
          logger.info(_this._factory.name + " create", _this.id);
          _this.adapter.createConnection(_this.options, function(err, client) {
            if (err) {
              return callback(err, null);
            }
            client.on('error', function(err) {
              _this.emit('error', err);
            });
            client.on('end', function(err) {
              if (client._destroying) {
                return;
              }
              _this.destroy(client);
            });
            callback(null, client);
          });
        };
      })(this),
      destroy: (function(_this) {
        return function(client) {
          if (client._destroying) {
            return;
          }
          logger.info(_this._factory.name + " destroy", _this.id);
          client._destroying = true;
          client.end();
        };
      })(this),
      max: this.options.maxConnection,
      min: this.options.minConnection,
      idle: this.options.idleTimeout * 1000
    });
    if (typeof next === 'function') {
      this.check(next);
    }
    return;
  }

  AdapterPool.prototype.check = function(next) {
    if ('function' !== typeof next) {
      next = function() {};
    }
    this.acquire((function(_this) {
      return function(err, connection) {
        if (err) {
          return next(err);
        }
        _this.release(connection);
        next();
      };
    })(this));
  };

  AdapterPool.prototype.getDialect = function() {
    return this.options.adapter;
  };

  AdapterPool.prototype.createConnector = function(options) {
    var Connector;
    Connector = require('./Connector');
    return new Connector(this, options);
  };

  AdapterPool.prototype.getMaxConnection = function() {
    return this.options.maxConnection;
  };

  return AdapterPool;

})(SemaphorePool);
