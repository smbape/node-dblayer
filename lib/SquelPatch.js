// Generated by CoffeeScript 1.9.3
var _, cls, squel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

squel = require('squel');

_ = require('lodash');

cls = squel.cls;

cls.HavingBlock = (function(superClass) {
  extend(HavingBlock, superClass);

  function HavingBlock(options) {
    HavingBlock.__super__.constructor.call(this, options);
    this.havings = [];
  }

  HavingBlock.prototype.having = function() {
    var c, condition, finalCondition, finalValues, i, idx, inValues, item, j, len, nextValue, ref, t, values;
    condition = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    condition = this._sanitizeCondition(condition);
    finalCondition = "";
    finalValues = [];
    if (condition instanceof cls.Expression) {
      t = condition.toParam();
      finalCondition = t.text;
      finalValues = t.values;
    } else {
      for (idx = i = 0, ref = condition.length; i < ref; idx = i += 1) {
        c = condition.charAt(idx);
        if ('?' === c && 0 < values.length) {
          nextValue = values.shift();
          if (Array.isArray(nextValue)) {
            inValues = [];
            for (j = 0, len = nextValue.length; j < len; j++) {
              item = nextValue[j];
              inValues.push(this._sanitizeValue(item));
            }
            finalValues = finalValues.concat(inValues);
            finalCondition += "(" + (((function() {
              var k, len1, results;
              results = [];
              for (k = 0, len1 = inValues.length; k < len1; k++) {
                item = inValues[k];
                results.push('?');
              }
              return results;
            })()).join(', ')) + ")";
          } else {
            finalCondition += '?';
            finalValues.push(this._sanitizeValue(nextValue));
          }
        } else {
          finalCondition += c;
        }
      }
    }
    if ("" !== finalCondition) {
      return this.havings.push({
        text: finalCondition,
        values: finalValues
      });
    }
  };

  HavingBlock.prototype.buildStr = function(queryBuilder) {
    var c, having, havingStr, i, idx, j, len, pIndex, ref, ref1;
    if (0 >= this.havings.length) {
      return "";
    }
    havingStr = "";
    ref = this.havings;
    for (i = 0, len = ref.length; i < len; i++) {
      having = ref[i];
      if ("" !== havingStr) {
        havingStr += ") AND (";
      }
      if (0 < having.values.length) {
        pIndex = 0;
        for (idx = j = 0, ref1 = having.text.length; j < ref1; idx = j += 1) {
          c = having.text.charAt(idx);
          if ('?' === c) {
            havingStr += this._formatValue(having.values[pIndex++]);
          } else {
            havingStr += c;
          }
        }
      } else {
        havingStr += having.text;
      }
    }
    return "HAVING (" + havingStr + ")";
  };

  HavingBlock.prototype.buildParam = function(queryBuilder) {
    var having, havingStr, i, j, len, len1, ref, ref1, ret, v, value;
    ret = {
      text: "",
      values: []
    };
    if (0 >= this.havings.length) {
      return ret;
    }
    havingStr = "";
    ref = this.havings;
    for (i = 0, len = ref.length; i < len; i++) {
      having = ref[i];
      if ("" !== havingStr) {
        havingStr += ") AND (";
      }
      havingStr += having.text;
      ref1 = having.values;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        v = ref1[j];
        ret.values.push(this._formatValueAsParam(v));
        value = this._formatValueAsParam(value);
      }
    }
    ret.text = "HAVING (" + havingStr + ")";
    return ret;
  };

  return HavingBlock;

})(cls.Block);

cls.Select = (function(superClass) {
  extend(Select, superClass);

  function Select(options, blocks) {
    blocks || (blocks = [
      new cls.StringBlock(options, 'SELECT'), new cls.DistinctBlock(options), new cls.GetFieldBlock(options), new cls.FromTableBlock(_.extend({}, options, {
        allowNested: true
      })), new cls.JoinBlock(_.extend({}, options, {
        allowNested: true
      })), new cls.WhereBlock(options), new cls.GroupByBlock(options), new cls.HavingBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.OffsetBlock(options)
    ]);
    Select.__super__.constructor.call(this, options, blocks);
  }

  Select.prototype.isNestable = function() {
    return true;
  };

  return Select;

})(cls.QueryBuilder);

module.exports = squel;
