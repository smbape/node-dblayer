// Generated by CoffeeScript 1.9.0
(function() {
  var cls, squel, _,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  squel = require('squel');

  _ = require('lodash');

  cls = squel.cls;

  cls.HavingBlock = (function(_super) {
    __extends(HavingBlock, _super);

    function HavingBlock(options) {
      HavingBlock.__super__.constructor.call(this, options);
      this.havings = [];
    }

    HavingBlock.prototype.having = function() {
      var c, condition, finalCondition, finalValues, idx, inValues, item, nextValue, t, values, _i, _j, _len, _ref;
      condition = arguments[0], values = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      condition = this._sanitizeCondition(condition);
      finalCondition = "";
      finalValues = [];
      if (condition instanceof cls.Expression) {
        t = condition.toParam();
        finalCondition = t.text;
        finalValues = t.values;
      } else {
        for (idx = _i = 0, _ref = condition.length; _i < _ref; idx = _i += 1) {
          c = condition.charAt(idx);
          if ('?' === c && 0 < values.length) {
            nextValue = values.shift();
            if (Array.isArray(nextValue)) {
              inValues = [];
              for (_j = 0, _len = nextValue.length; _j < _len; _j++) {
                item = nextValue[_j];
                inValues.push(this._sanitizeValue(item));
              }
              finalValues = finalValues.concat(inValues);
              finalCondition += "(" + (((function() {
                var _k, _len1, _results;
                _results = [];
                for (_k = 0, _len1 = inValues.length; _k < _len1; _k++) {
                  item = inValues[_k];
                  _results.push('?');
                }
                return _results;
              })()).join(', ')) + ")";
            } else {
              finalCondition += '?';
              finalValues.push(this._sanitizeValue(nextValue));
            }
          } else {
            finalCondition += c;
          }
        }
      }
      if ("" !== finalCondition) {
        return this.havings.push({
          text: finalCondition,
          values: finalValues
        });
      }
    };

    HavingBlock.prototype.buildStr = function(queryBuilder) {
      var c, having, havingStr, idx, pIndex, _i, _j, _len, _ref, _ref1;
      if (0 >= this.havings.length) {
        return "";
      }
      havingStr = "";
      _ref = this.havings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        having = _ref[_i];
        if ("" !== havingStr) {
          havingStr += ") AND (";
        }
        if (0 < having.values.length) {
          pIndex = 0;
          for (idx = _j = 0, _ref1 = having.text.length; _j < _ref1; idx = _j += 1) {
            c = having.text.charAt(idx);
            if ('?' === c) {
              havingStr += this._formatValue(having.values[pIndex++]);
            } else {
              havingStr += c;
            }
          }
        } else {
          havingStr += having.text;
        }
      }
      return "HAVING (" + havingStr + ")";
    };

    HavingBlock.prototype.buildParam = function(queryBuilder) {
      var having, havingStr, ret, v, value, _i, _j, _len, _len1, _ref, _ref1;
      ret = {
        text: "",
        values: []
      };
      if (0 >= this.havings.length) {
        return ret;
      }
      havingStr = "";
      _ref = this.havings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        having = _ref[_i];
        if ("" !== havingStr) {
          havingStr += ") AND (";
        }
        havingStr += having.text;
        _ref1 = having.values;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          v = _ref1[_j];
          ret.values.push(this._formatValueAsParam(v));
          value = this._formatValueAsParam(value);
        }
      }
      ret.text = "HAVING (" + havingStr + ")";
      return ret;
    };

    return HavingBlock;

  })(cls.Block);

  cls.Select = (function(_super) {
    __extends(Select, _super);

    function Select(options, blocks) {
      if (blocks == null) {
        blocks = null;
      }
      blocks || (blocks = [
        new cls.StringBlock(options, 'SELECT'), new cls.DistinctBlock(options), new cls.GetFieldBlock(options), new cls.FromTableBlock(_.extend({}, options, {
          allowNested: true
        })), new cls.JoinBlock(_.extend({}, options, {
          allowNested: true
        })), new cls.WhereBlock(options), new cls.GroupByBlock(options), new cls.HavingBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.OffsetBlock(options)
      ]);
      Select.__super__.constructor.call(this, options, blocks);
    }

    Select.prototype.isNestable = function() {
      return true;
    };

    return Select;

  })(cls.QueryBuilder);

  module.exports = squel;

}).call(this);
