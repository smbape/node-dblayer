// Generated by CoffeeScript 1.12.4
var SchemaCompiler, _,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

module.exports = SchemaCompiler = (function() {
  function SchemaCompiler(options) {
    var columnCompiler, i, j, len, len1, method, prop, ref, ref1;
    if (options == null) {
      options = {};
    }
    columnCompiler = this.columnCompiler = new this.ColumnCompiler(options);
    this.indent = options.indent || '    ';
    this.LF = options.LF || '\n';
    this.delimiter = options.delimiter || ';';
    ref = ['adapter', 'args', 'words'];
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      this[prop] = columnCompiler[prop];
    }
    ref1 = ['escape', 'escapeId', 'escapeSearch', 'escapeBeginWith', 'escapeEndWith'];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      method = ref1[j];
      if ('function' === typeof this.adapter[method]) {
        this[method] = this.adapter[method].bind(this.adapter);
      }
    }
    this.options = _.clone(options);
  }

  return SchemaCompiler;

})();

SchemaCompiler.prototype.createTable = function(tableModel, options) {
  var LF, altersql, args, colsql, column, columnCompiler, columnId, columns, constraint, count, delete_rule, delimiter, err, escapeId, fk, fkName, indent, indexName, length, pk, pkName, ref, ref1, ref2, referenced_column, referenced_table, spaceLen, spec, tableName, tableNameId, tablespec, tablesql, type, uk, ukName, update_rule, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, columnCompiler = ref.columnCompiler, args = ref.args, indent = ref.indent, LF = ref.LF, delimiter = ref.delimiter;
  tableName = tableModel.name;
  tableNameId = escapeId(tableName);
  args.tableModel = tableName;
  tablesql = [];
  spaceLen = ' '.repeat(66 - 10 - tableName.length - 2);
  tablesql.push("/*==============================================================*/\n/* Table: " + tableName + spaceLen + "*/\n/*==============================================================*/");
  tablesql.push.apply(tablesql, [LF, words.create_table, ' ']);
  if (options.if_not_exists) {
    tablesql.push(words.if_not_exists);
    tablesql.push(' ');
  }
  tablesql.push.apply(tablesql, [tableNameId, ' (', LF]);
  tablespec = [];
  ref1 = tableModel.columns;
  for (column in ref1) {
    spec = ref1[column];
    columnId = escapeId(column);
    length = columnId.length;
    spaceLen = 21 - length;
    if (spaceLen <= 0) {
      spaceLen = 1;
      length++;
    } else {
      length = 21;
    }
    colsql = [columnId, ' '.repeat(spaceLen)];
    args.column = column;
    type = columnCompiler.getTypeString(spec);
    colsql.push(type);
    if (!type) {
      console.log(spec);
    }
    length += type.length;
    spaceLen = 42 - length;
    if (spaceLen <= 0) {
      spaceLen = 1;
    }
    colsql.push(' '.repeat(spaceLen));
    colsql.push(columnCompiler.getColumnModifier(spec));
    tablespec.push(indent + colsql.join(' '));
  }
  if ((pk = tableModel.constraints['PRIMARY KEY']) && !_.isEmpty(pk)) {
    count = 0;
    for (pkName in pk) {
      columns = pk[pkName];
      if (++count === 2) {
        err = new Error(tableName + " has more than one primary key");
        err.code = 'MULTIPLE_PK';
        throw err;
      }
      tablespec.push(indent + words.constraint + ' ' + columnCompiler.pkString(pkName, columns));
    }
  }
  if ((uk = tableModel.constraints.UNIQUE) && !_.isEmpty(uk)) {
    for (ukName in uk) {
      columns = uk[ukName];
      tablespec.push(indent + words.constraint + ' ' + columnCompiler.ukString(ukName, columns));
    }
  }
  tablesql.push(tablespec.join(',' + LF));
  tablesql.push(LF);
  tablesql.push(')');
  if (tableModel.indexes && !_.isEmpty(tableModel.indexes)) {
    tablesql.push(delimiter);
    tablesql.push(LF);
    count = 0;
    ref2 = tableModel.indexes;
    for (indexName in ref2) {
      columns = ref2[indexName];
      if (count === 0) {
        count = 1;
      } else {
        tablesql.push(delimiter);
        tablesql.push(LF);
      }
      tablesql.push(LF);
      spaceLen = ' '.repeat(66 - 10 - indexName.length - 2);
      tablesql.push("/*==============================================================*/\n/* Index: " + indexName + spaceLen + "*/\n/*==============================================================*/");
      tablesql.push.apply(tablesql, [LF, words.create_index, ' ', columnCompiler.indexString(indexName, columns, tableNameId)]);
    }
  }
  altersql = [];
  if ((fk = tableModel.constraints['FOREIGN KEY']) && !_.isEmpty(fk)) {
    for (fkName in fk) {
      constraint = fk[fkName];
      column = constraint.column, referenced_table = constraint.referenced_table, referenced_column = constraint.referenced_column, delete_rule = constraint.delete_rule, update_rule = constraint.update_rule;
      altersql.push.apply(altersql, [LF, words.alter_table, ' ', escapeId(tableName), LF, indent, words.add_constraint, ' ', escapeId(fkName), ' ', words.foreign_key, ' (', escapeId(column), ')', LF, indent, indent, words.references, ' ', escapeId(referenced_table), ' (', escapeId(referenced_column) + ')']);
      delete_rule = delete_rule ? delete_rule.toLowerCase() : 'restrict';
      update_rule = update_rule ? update_rule.toLowerCase() : 'restrict';
      if (indexOf.call(this.validUpdateActions, delete_rule) < 0) {
        err = new Error("unknown delete rule " + delete_rule);
        err.code = 'UPDATE RULE';
        throw err;
      }
      if (indexOf.call(this.validUpdateActions, update_rule) < 0) {
        err = new Error("unknown update rule " + update_rule);
        err.code = 'UPDATE RULE';
        throw err;
      }
      altersql.push.apply(altersql, [LF, indent, indent, words.on_delete, ' ', words[delete_rule], ' ', words.on_update, ' ', words[update_rule], delimiter, LF]);
    }
  }
  return {
    create: tablesql.join(''),
    alter: altersql.slice(1).join('')
  };
};

SchemaCompiler.prototype.dropTable = function(tableName, options) {
  var escapeId, ref, tablesql, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId;
  tablesql = [words.drop_table];
  if (options.if_exists) {
    tablesql.push(words.if_exists);
  }
  tablesql.push(escapeId(tableName));
  if (options.cascade) {
    tablesql.push(words.cascade);
  } else if (options.restrict) {
    tablesql.push(words.restrict);
  }
  return tablesql.join(' ');
};

SchemaCompiler.prototype.addColumn = function(tableName, column, spec, options) {
  var LF, altersql, args, columnCompiler, columnId, escapeId, indent, ref, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, columnCompiler = ref.columnCompiler, args = ref.args, indent = ref.indent, LF = ref.LF;
  args.table = tableName;
  args.column = column;
  columnId = escapeId(column);
  altersql = [words.alter_table, ' '];
  altersql.push.apply(altersql, [escapeId(tableName), LF, indent, words.add_column, ' ', escapeId(column), ' ', columnCompiler.getTypeString(spec), ' ', columnCompiler.getColumnModifier(spec)]);
  return altersql.join('');
};

SchemaCompiler.prototype.addPrimaryKey = function(tableName, newPkName, newColumns, options) {
  var LF, altersql, columnCompiler, escapeId, indent, ref, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, columnCompiler = ref.columnCompiler, indent = ref.indent, LF = ref.LF;
  altersql = [words.alter_table, ' '];
  altersql.push.apply(altersql, [escapeId(tableName), LF, indent, words.add_constraint, ' ', columnCompiler.pkString(newPkName, newColumns)]);
  return altersql.join('');
};

SchemaCompiler.prototype.addForeignKey = function(tableModel, key, options) {
  var LF, altersql, column, delete_rule, err, escapeId, fkName, indent, ref, referenced_column, referenced_table, update_rule, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, indent = ref.indent, LF = ref.LF;
  altersql = [words.alter_table, ' '];
  fkName = key.name, column = key.column, referenced_table = key.referenced_table, referenced_column = key.referenced_column, delete_rule = key.delete_rule, update_rule = key.update_rule;
  altersql.push.apply(altersql, [escapeId(tableModel.name), LF, indent, words.add_constraint, ' ', escapeId(fkName), ' ', words.foreign_key, ' (', escapeId(column), ')', LF, indent, indent, words.references, ' ', escapeId(referenced_table), ' (', escapeId(referenced_column) + ')']);
  delete_rule = delete_rule ? delete_rule.toLowerCase() : 'restrict';
  update_rule = update_rule ? update_rule.toLowerCase() : 'restrict';
  if (indexOf.call(this.validUpdateActions, delete_rule) < 0) {
    err = new Error("unknown delete rule " + delete_rule);
    err.code = 'UPDATE RULE';
    throw err;
  }
  if (indexOf.call(this.validUpdateActions, update_rule) < 0) {
    err = new Error("unknown update rule " + update_rule);
    err.code = 'UPDATE RULE';
    throw err;
  }
  altersql.push.apply(altersql, [LF, indent, indent, words.on_delete, ' ', words[delete_rule], ' ', words.on_update, ' ', words[update_rule]]);
  return altersql.join('');
};

SchemaCompiler.prototype.addUniqueIndex = function(tableName, indexName, columns, options) {
  var LF, altersql, escapeId, indent, ref, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, indent = ref.indent, LF = ref.LF;
  altersql = [words.alter_table, ' '];
  altersql.push.apply(altersql, [escapeId(tableName), LF, indent, words.add_constraint, ' ', escapeId(indexName), ' ', words.unique, ' (', columns.map(escapeId).join(', '), ')']);
  return altersql.join('');
};

SchemaCompiler.prototype.addIndex = function(tableName, indexName, columns, options) {
  var columnCompiler, escapeId, ref, words;
  options = _.defaults({}, options, this.options);
  ref = this, words = ref.words, escapeId = ref.escapeId, columnCompiler = ref.columnCompiler;
  return [words.create_index, ' ', columnCompiler.indexString(indexName, columns, escapeId(tableName))].join('');
};

SchemaCompiler.prototype.getDatabaseModel = function(pMgr, options) {
  var className, column, dbmodel, definition, foreignKey, i, index, indexKey, j, key, len, len1, mixin, name, names, parentDef, primaryKey, prop, propDef, propToColumn, properties, ref, ref1, ref2, ref3, ref4, ref5, tableMdel, tableName, unique;
  dbmodel = {};
  propToColumn = function(prop) {
    return definition.properties[prop].column;
  };
  ref = pMgr.classes;
  for (className in ref) {
    definition = ref[className];
    tableName = definition.table;
    tableMdel = dbmodel[tableName] = {
      name: tableName,
      columns: {},
      constraints: {
        'PRIMARY KEY': {},
        'FOREIGN KEY': {},
        'UNIQUE': {}
      },
      indexes: {}
    };
    if (definition.id && definition.id.column) {
      primaryKey = 'PK_' + (definition.id.pk || tableName);
      tableMdel.constraints['PRIMARY KEY'][primaryKey] = [definition.id.column];
      column = tableMdel.columns[definition.id.column] = this.getSpec(definition.id, pMgr);
      if (!column.type) {
        throw new Error("[" + className + "] No type has been defined for id");
      }
      column.nullable = false;
      if (definition.id.className) {
        parentDef = pMgr._getDefinition(definition.id.className);
        this.addForeignKeyConstraint('EXT', tableMdel, definition.id, parentDef, _.defaults({
          fkindex: false
        }, options));
      }
    }
    if (_.isEmpty(tableMdel.constraints['PRIMARY KEY'])) {
      delete tableMdel.constraints['PRIMARY KEY'];
    }
    ref1 = definition.mixins;
    for (index = i = 0, len = ref1.length; i < len; index = ++i) {
      mixin = ref1[index];
      if (mixin.column === definition.id.column) {
        continue;
      }
      parentDef = pMgr._getDefinition(mixin.className);
      column = tableMdel.columns[mixin.column] = this.getSpec(mixin, pMgr);
      if (!column.type) {
        throw new Error("[" + className + "] No type has been defined for mixin " + mixin.className);
      }
      column.nullable = false;
      ref2 = this.addForeignKeyConstraint('EXT', tableMdel, mixin, parentDef, _.defaults({
        fkindex: false
      }, options)), foreignKey = ref2[0], indexKey = ref2[1];
      tableMdel.constraints.UNIQUE[indexKey] = [mixin.column];
    }
    ref3 = definition.properties;
    for (prop in ref3) {
      propDef = ref3[prop];
      column = tableMdel.columns[propDef.column] = this.getSpec(propDef, pMgr);
      if (!column.type) {
        throw new Error("[" + className + "] No type has been defined for property " + prop);
      }
      if (propDef.className) {
        parentDef = pMgr._getDefinition(propDef.className);
        this.addForeignKeyConstraint('HAS', tableMdel, propDef, parentDef, options);
      }
    }
    if (_.isEmpty(tableMdel.constraints['FOREIGN KEY'])) {
      delete tableMdel.constraints['FOREIGN KEY'];
    }
    ref4 = definition.constraints, unique = ref4.unique, names = ref4.names;
    for (key in unique) {
      properties = unique[key];
      name = 'UK_' + names[key];
      tableMdel.constraints.UNIQUE[name] = properties.map(propToColumn);
    }
    if (_.isEmpty(tableMdel.constraints.UNIQUE)) {
      delete tableMdel.constraints.UNIQUE;
    }
    ref5 = definition.indexes;
    for (properties = j = 0, len1 = ref5.length; j < len1; properties = ++j) {
      name = ref5[properties];
      tableMdel.indexes[name] = properties.map(propToColumn);
    }
  }
  return dbmodel;
};

SchemaCompiler.prototype.getSpec = function(model, pMgr) {
  var spec;
  spec = _.pick(model, pMgr.specProperties);
  if (spec.defaultValue) {
    spec.defaultValue = this.escape(spec.defaultValue);
  }
  return spec;
};

SchemaCompiler.prototype.addForeignKeyConstraint = function(name, tableMdel, propDef, parentDef, options) {
  var foreignKey, indexKey, keyName;
  if (options == null) {
    options = {};
  }
  keyName = propDef.fk || (tableMdel.name + "_" + propDef.column + "_" + name + "_" + parentDef.table + "_" + parentDef.id.column);
  foreignKey = "FK_" + keyName;
  tableMdel.constraints['FOREIGN KEY'][foreignKey] = {
    column: propDef.column,
    referenced_table: parentDef.table,
    referenced_column: parentDef.id.column,
    update_rule: 'RESTRICT',
    delete_rule: 'RESTRICT'
  };
  indexKey = keyName + "_FK";
  if (!propDef.unique && propDef.fkindex !== false && options.fkindex !== false) {
    tableMdel.indexes[indexKey] = [propDef.column];
  }
  return [foreignKey, indexKey];
};
